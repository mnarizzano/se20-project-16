
<doc id="1745121" url="https://it.wikipedia.org/wiki?curid=1745121" title="Outlier">
Outlier
Outlier è un termine utilizzato in statistica per definire, in un insieme di osservazioni, un valore anomalo e aberrante. Un valore quindi chiaramente distante dalle altre osservazioni disponibili.
In statistica viene definito outlier un valore al di fuori dall'intervallo:
Dove formula_2 e formula_3 sono rispettivamente primo e terzo quartile. formula_4 è una costante che regola l'ampiezza dell'intervallo. Normalmente assume il valore unitario.
Gli outlier sono valori numericamente distanti dal resto dei dati raccolti (ad esempio, in un campionamento). Le statistiche che derivano da campioni contenenti outlier possono essere fuorvianti. Per esempio, se misurassimo la temperatura di dieci oggetti presenti in una stanza, la maggior parte dei quali risultasse avere una temperatura compresa fra 20 e 25 gradi Celsius, allora il forno acceso, avente una temperatura di 350 gradi, sarebbe un dato aberrante. La mediana dei valori sarebbe circa 23, mentre la temperatura media salirebbe a circa 55 gradi: un indice chiaramente non rappresentativo della maggioranza dei valori di temperatura riscontrati nella stanza. In questo caso, la mediana rifletterebbe meglio della media aritmetica le misure della temperatura degli oggetti. Gli outliers possono essere indicativi del fatto che, in un dato campione, alcuni dati appartengono ad una popolazione differente rispetto a quella del resto del campione.
Nella maggioranza dei grandi campioni, alcuni dati saranno più lontani dalla media del campione di quanto sarebbe logico aspettarsi. Ciò può essere dovuto ad un errore sistematico che si è verificato nella raccolta dei dati, oppure a una fallacia nella teoria che ha orientato l'assunzione di una data distribuzione campionaria di probabilità, ma potrebbe anche essere semplicemente dovuto al caso, che ha fatto sì che nella raccolta dei dati alcune osservazioni abbiano prodotto dati molto lontani dai valori medi del campione. Inoltre, gli outliers potrebbero essere indicativi di dati errati, procedure erronee o aree sperimentali in cui alcune teorie potrebbero non essere valide. Tuttavia, un piccolo numero di dati aberranti non dovuti a condizioni anomale è dato per scontato nei grandi campioni.
Stimatori poco influenzati dai dati aberranti sono detti robusti.
</doc>

<doc id="1845509" url="https://it.wikipedia.org/wiki?curid=1845509" title="Significatività">
Significatività
In statistica la significatività è la possibilità rilevante che compaia un determinato valore. Ci si riferisce anche come "statisticamente differente da zero"; ciò non significa che la "significatività" sia rilevante, o vasta, come indurrebbe a pensare la parola. Ma solo che è diversa dal numero limite.
Il livello di significatività di un test è dato solitamente da una verifica del test d'ipotesi. Nel caso più semplice è definita come la probabilità di accettare o rigettare l'ipotesi nulla.
I livelli di significatività sono solitamente rappresentati con la lettera greca α (alfa). I livelli più usati sono 5% (α=0,05) e 1% (α=0,01); nel caso di ipotesi a carattere prevalentemente esplorativo è consuetudine adoperare un livello di significatività al 10% (α=0,1). Se il test di verifica d'ipotesi dà un valore p minore del livello α, l'ipotesi nulla è rifiutata.
Tali risultati sono informalmente riportati come 'statisticamente significativi'. Per esempio se si sostiene che "c'è solo una possibilità su mille che ciò possa accadere per coincidenza," viene usato un livello di significatività dello 0,1%. Più basso è il livello di significatività, maggiore è l'evidenza. In alcune situazioni conviene esprimere la significatività statistica con 1 − α. In generale, quando si interpreta una significatività stabilita, bisogna stare attenti nell'indicare che cosa, precisamente è stato testato statisticamente.
Differenti livelli di α hanno differenti vantaggi e svantaggi. α-livelli più bassi danno maggiore confidenza nella determinazione della significatività, ma corrono maggiori rischi di errore nel respingere una falsa ipotesi nulla (un errore di tipo II, o "falsa determinazione negativa"), e così hanno maggiore potenza statistica. La selezione di un α-livello inevitabilmente implica un compromesso fra significatività e potenza, e di conseguenza, fra errore tipo I ed errore tipo II.
In alcuni campi, per esempio nella fisica nucleare ed in quella delle particelle, si usa esprimere la significatività statistica in unità di "σ" (sigma), la deviazione standard di una distribuzione gaussiana. Una significatività statistica di "formula_1" può essere convertita in un valore di α usando la funzione errore:
L'uso di σ è motivato dalla onnipresenza della distribuzione gaussiana nella 
misura delle incertezze. Per esempio se una teoria prevede che un parametro abbia un valore, ad esempio 100, e ad una misurazione indica che il parametro è 100 ± 3, allora bisogna riportare la misura come una "deviazione 3σ" dalla previsione teorica. in termini di α, questa situazione è equivalente al dire che "supponendo vera la teoria, la possibilità di ottenere che il risultato sperimentale coincida è dello 0,27%" (poiché 1  − erf(3/√2) = 0.0027).
Fissati i livelli di significatività come quelli menzionati in seguito possono essere considerati come utili nelle analisi di dati esploratorie. Comunque, la moderna statistica è dell'avviso che, dove il risultato di un test è essenzialmente il risultato finale di un esperimento o di altro studio, il p-valore deve essere considerato esplicitamente. Inoltre, ed è importante, bisogna considerare se e come il p-valore è significativo o meno. Questo consente di accedere al massimo delle informazioni che devono essere trasferiti da un riassunto degli studi nelle meta-analisi.
Un errore comune è ritenere che un risultato statisticamente significativo sia sempre di significatività pratica, o dimostri un largo effetto nella popolazione. Sfortunatamente, questo problema si incontra diffusamente negli scritti scientifici. Dato un campione sufficientemente grande, per esempio, si può scoprire che differenze estremamente piccole e non visibili sono statisticamente significative, ma la significatività statistica non dice niente di una significatività pratica di una differenza.
Uno dei problemi più comuni nel testare la significatività è la tendenza delle comparazioni multiple a tendere a significative differenze spurie anche dove l'ipotesi nulla è vera. Per esempio, in uno studio di venti comparazioni, usando un 
α-livello del 5%, una comparazione può effettivamente riportare un risultato significativo nonostante sia vera l'ipotesi di nullità. in questi casi i p-valori sono corretti al fine di controllare o il valore falso o l'errore familiare.
Un problema addizionale è che si ritiene che le analisi frequentiste dei p-valori esagerino la ""significatività statistica"". Si veda il fattore di Bayes per i dettagli.
J. Scott Armstrong, negli articoli "Significance Tests Harm Progress in Forecasting," e "Statistical Significance Tests are Unnecessary Even When Properly Done," espone la sua posizione secondo cui in alcuni casi, seppure eseguiti correttamente, i test di significatività statistica non sarebbero utili. A suo parere, un certo numero di tentativi ha fallito nel trovare prove empiriche che sostenessero l'uso di test di significatività, ed i test di significatività statistica usati da soli potrebbero essere nocivi allo sviluppo della conoscenza scientifica perché distrarrebbero i ricercatori dall'uso di metodi statistici in alcuni casi più adatti. 
Armstrong suggerisce quindi che secondo lui i ricercatori dovrebbero evitare i test di significatività statistica, e dovrebbero piuttosto fare uso di strumenti di area di effetto, intervalli di fiducia, ripetizioni/estensioni, e meta-analisi.
La significatività statistica può essere considerata come la fiducia che si ha in un dato risultato. In uno studio di comparazione, essa dipende dalla differenza relativa tra i gruppi confrontati, la quantità delle misurazioni e il rumore associato alle misurazioni. In altre parole, la fiducia che si ha che un dato risultato sia non casuale (cioè non una conseguenza di un caso) dipende dal rapporto segnale-rumore (SNR) e misura campione. Esprimendosi matematicamente, la fiducia che un risultato non sia casuale è dato dalla seguente formula di Sackett:
Per chiarezza, la succitata formula è rappresentata tabularmente qui di seguito.
Dipendenza della fiducia con rumore, segnale e misura campione (forma tabulare)
In parole la dipendenza di una fiducia è maggiore se il rumore è basso o la misura campione è estesa o l'ampiezza effettiva (del segnale) è larga. La fiducia di un risultato (e l'associato intervallo di fiducia) "non" dipende dagli effetti della sola ampiezza effettiva del segnale. Se la misura campione è grande e il rumore e piccolo un'ampiezza effettiva di segnale può essere misurata con grande fiducia. Sebbene un'ampiezza effettiva viene considerata importante essa dipende nel contesto degli eventi comparati.
In medicina, piccole ampiezze effettive (riflesse da piccoli aumenti di rischio) sono spesso considerate clinicamente rilevanti e sono frequentemente usati per guidare decisioni di trattamento (se c'è una grande fiducia in essi). Sebbene un dato trattamento è considerato un giusto tentativo esso dipende dai rischi, dai benefici e dai costi.
</doc>

<doc id="6539843" url="https://it.wikipedia.org/wiki?curid=6539843" title="Boosting">
Boosting
Il boosting è una tecnica di machine learning che rientra nella categoria dell'Apprendimento ensemble. Nel boosting più modelli vengono generati consecutivamente dando sempre più peso agli errori effettuati nei modelli precedenti. In questo modo si creano modelli via via più "attenti" agli aspetti che hanno causato inesattezze nei modelli precedenti, ottenendo infine un modello aggregato avente migliore accuratezza di ciascun modello che lo costituisce.
In algoritmi come Adaboost, l'output del meta-classificatore è dato dalla somma pesata delle predizioni dei singoli modelli. Ogni qual volta un modello viene addestrato, ci sarà una fase di ripesaggio delle istanze. L'algoritmo di boosting tenderà a dare un peso maggiore alle istanze misclassificate, nella speranza che il successivo modello sia più esperto su quest'ultime.
In generale si ha che l'errore di predizione in un problema di apprendimento supervisionato è dato da:
formula_1
Il boosting mira a ridurre la varianza.
</doc>

<doc id="434228" url="https://it.wikipedia.org/wiki?curid=434228" title="Information retrieval">
Information retrieval
L'information retrieval (IR) (in italiano "recupero delle informazioni") è l'insieme delle tecniche utilizzate per gestire la rappresentazione, la memorizzazione, l'organizzazione e l'accesso ad oggetti contenenti informazioni quali documenti, pagine web, cataloghi online e oggetti multimediali. Il termine è stato coniato da Calvin Mooers alla fine degli anni quaranta del Novecento ed oggi è usato quasi esclusivamente in ambito informatico.
L'information retrieval è un campo interdisciplinare che nasce dall'incrocio di discipline diverse coinvolgendo la psicologia cognitiva, l'architettura informativa, la filosofia (vedi la voce ontologia), il "design", il comportamento umano sull'informazione, la linguistica, la semiotica, la scienza dell'informazione e l'informatica. Molte università e biblioteche pubbliche utilizzano sistemi di information retrieval per fornire accesso a pubblicazioni, libri ed altri documenti.
Lo scopo dell'information retrieval è di soddisfare il cosiddetto "bisogno informativo dell'utente", ovvero garantire a quest'ultimo, in seguito ad una sua ricerca, i documenti e le informazioni che rispondono alla sua richiesta.
Due concetti sono di fondamentale importanza per analizzare un sistema di information retrieval: query ed oggetto.
Comunemente, si definisce "task" di un sistema di "information retrieval" una situazione tipica che un sistema di questo genere deve risolvere.
Nel momento in cui un utente intende usare un qualsiasi sistema di reperimento dell'informazione (per esempio, un motore di ricerca) per acquisire informazioni su un determinato argomento, questi deve tradurre tale necessità in una query; il sistema di information retrieval ha il compito di restituire, a partire da essa, tutti i documenti rilevanti alla richiesta effettuata.
Ci sono molti modi per misurare quanto l'informazione intesa si associa bene all'informazione recuperata.
La precisione (in inglese "precision") è la proporzione di documenti pertinenti fra quelli recuperati:
Nella classificazione binaria la precisione è analoga al valore positivo di previsione. 
La precisione può anche essere valutata rispetto a un certo valore soglia, indicato con "P@n", piuttosto che relativamente a tutti i documenti recuperati: in questo modo, si può valutare quanti fra i primi "n" documenti recuperati sono rilevanti per la query.
Il significato e l'uso del termine "precisione" nel campo dell'information retrieval differiscono quindi dalla definizione di accuratezza e precisione tipiche di altre discipline scientifiche e tecnologiche.
Il recupero o richiamo (in inglese "recall") è la proporzione fra il numero di documenti rilevanti recuperati e il numero di tutti i documenti rilevanti disponibili nella collezione considerata:
Nella classificazione binaria, questo valore è chiamato sensitività.
La misura F (in inglese "F-measure") è la media armonica pesata fra precisione e recupero. La versione tradizionale, detta anche "bilanciata", è data da:
Questa misura è anche detta formula_2, perché sia la precisione che il recupero nella formula precedente hanno appunto il peso 1.
In generale, la formula è:
Altre due formule comuni sono formula_4, che assegna alla precisione un peso doppio rispetto al recupero, e la formula_5, che al contrario pesa il recupero al doppio della precisione.
Per concludere con successo una ricerca di informazioni, è necessario rappresentare i documenti in qualche modo. C'è un certo numero di modelli aventi tale scopo. Essi possono essere classificati secondo due criteri, come mostrato nella figura a destra: in base ad un criterio matematico e in base alle proprietà del modello (tradotto da fonte originale logos-verlag.de).
Sistemi di Information Retrieval in campo scientifico
Software di Information Retrieval Open Source
Principali gruppi di ricerca sull'Information Retrieval
Approfondimenti
</doc>

<doc id="480718" url="https://it.wikipedia.org/wiki?curid=480718" title="Discesa del gradiente">
Discesa del gradiente
In ottimizzazione e analisi numerica il metodo di discesa del gradiente (detto anche "metodo del gradiente", "metodo steepest descent" o "metodo di discesa più ripida") è una tecnica che consente di determinare i punti di massimo e minimo di una funzione di più variabili.
Il metodo è stato sviluppato - e pubblicato nel 1847 - dal matematico francese Augustin-Louis Cauchy nel tentativo di risolvere il problema di determinare l'orbita di un corpo celeste a partire dalle sue equazioni del moto.
Si supponga di voler minimizzare la funzioneformula_1 e si scelga come soluzione iniziale il vettore formula_2. Allora
e, muovendosi in un intorno di formula_4:
Questi calcoli mostrano che, per individuare dei punti - "vicini" a formula_4 - in corrispondenza dei quali la funzione assuma un valore minore di formula_7, conviene spostarsi lungo direzioni che abbiano la prima e la terza componente formula_8 più piccole o seconda componente formula_9 più grande. Inoltre esistono delle direzioni "preferenziali" lungo le quali la funzione formula_10 decresce più velocemente (ad esempio scegliere una coordinata formula_11 più piccola è preferibile, ad esempio, rispetto a far diminuire formula_12).
La procedura può essere iterata partendo da un nuovo punto, ad esempio formula_13, fino ad individuare un minimo per formula_10. L'esempio mostra che una procedura che aggiorni la soluzione in modo iterativo sulla base delle informazioni disponibili "localmente" può portare ad individuare un punto di minimo per la funzione assegnata.
Si voglia risolvere il seguente problema di ottimizzazione non vincolata nello spazio formula_15-dimensionale formula_16
La tecnica di discesa secondo gradiente si basa sul fatto che, per una data funzione formula_18, la direzione di massima discesa in un assegnato punto formula_19 corrisponde a quella determinata dall'opposto del suo gradiente in quel punto formula_20. Questa scelta per la direzione di discesa garantisce che la soluzione tenda a un punto di minimo di formula_10. Il metodo del gradiente prevede dunque di partire da una soluzione iniziale formula_4 scelta arbitrariamente e di procedere iterativamente aggiornandola come
dove formula_24 corrisponde alla lunghezza del passo di discesa, la cui scelta diventa cruciale nel determinare la velocità con cui l'algoritmo convergerà alla soluzione richiesta.
Si parla di metodo "stazionario" nel caso in cui si scelga un passo formula_25 costante per ogni formula_26, viceversa il metodo si definisce "dinamico". In quest'ultimo caso una scelta conveniente, ma computazionalmente più onerosa rispetto a un metodo stazionario, consiste nell'ottimizzare, una volta determinata la direzione di discesa formula_27, la funzione di una variabile formula_28 in maniera analitica o in maniera approssimata. Si noti che, a seconda della scelta del passo di discesa, l'algoritmo potrà convergere a uno qualsiasi dei minimi della funzione formula_10, sia esso locale o globale.
Lo schema generale per l'ottimizzazione di una funzione formula_18 mediante metodo del gradiente è il seguente:
Un caso particolare di applicazione del metodo del gradiente consiste nella risoluzione di sistemi lineari della forma
dove formula_33 è una matrice simmetrica e definita positiva.
Per le proprietà di formula_33 la soluzione di tale problema è equivalente alla procedura di minimizzazione della forma quadratica associata:
Infatti:
da cui
Per la funzione formula_38 si ha che la direzione di massima discesa nel punto formula_39 è:
coincidente con il residuo formula_41 del sistema lineare. Dunque la direzione di discesa scelta a ogni iterazione è formula_42.
Inoltre vale la seguente relazione:
che permette di calcolare analiticamente il passo formula_44 ottimale. Infatti, imponendo la condizione di stazionarietà
si ricava
L'algoritmo del metodo del gradiente per la risoluzione di sistemi lineari è dunque
In aritmetica floating point la condizione del ciclo while può essere valutata verificando che la norma del residuo formula_48 non sia più piccola di una tolleranza impostata dall'utente.
In molti casi è possibile accelerare la velocità di convergenza dell'algoritmo migliorando le proprietà di condizionamento della matrice formula_33. Si introduca a tal fine una matrice di precondizionamento formula_50 simmetrica e definita positiva.
Lo schema risolutivo in questo caso diventa:
Il metodo del gradiente coniugato costituisce una variante del metodo del gradiente in cui viene effettuata una scelta diversa, ma particolarmente conveniente nel caso di sistemi lineari simmetrici e definiti positivi, per le direzioni di discesa formula_27. Tale scelta garantisce la convergenza del metodo (in aritmetica esatta) in un numero di iterazioni pari al più alla dimensione del sistema da risolvere.
È possibile dimostrare che l'errore commesso alla formula_26-esima iterazione del metodo del gradiente soddisfa la seguente stima:
dove
formula_56 indica il numero di condizionamento in norma formula_57 di formula_33 e formula_59 è la norma indotta da formula_33.
Nel caso precondizionato vale la stessa stima con
Si riporta un esempio di possibile implementazione del metodo del gradiente nella versione precondizionata compatibile con i linguaggi di programmazione Octave e MATLAB.
Quando la funzione obiettivo è troppo costosa da calcolare ad ogni iterazione, ma può essere scomposta in una somma di molti addendi (ad esempio, la somma del costo calcolato su ogni singolo record in un dataset), il gradiente può essere approssimato stocasticamente restringendo la somma su un sottinsieme di addendi ad ogni iterazione, metodo noto come discesa stocastica del gradiente.
La discesa del gradiente è ampiamente utilizzata in statistica e apprendimento automatico per l'addestramento tramite apprendimento supervisionato di modelli come reti neurali artificiali e modelli grafici. Il principio è noto come regola delta, e consiste nel valutare il modello su un input il cui corrispondente output esatto sia noto, e correggere ciascun parametro del modello in una quantità proporzionale (ma di segno opposto) rispetto al suo contributo all'errore sul risultato. L'algoritmo usato nelle reti neurali per implementare questo principio è noto come retropropagazione dell'errore, che consiste in un'applicazione della discesa del gradiente, essendo il contributo di ciascun parametro all'errore del modello dato dalla derivata parziale della funzione di perdita rispetto al parametro stesso.
La regola, classificabile fra i metodi per l'apprendimento supervisionato, può essere applicata a reti neurali di tipo "in avanti" (cioè con propagazione unidirezionale dei segnali, in inglese: "feedforward") e permette di calcolare la differenza tra i valori di output che la rete ottiene e quelli che invece dovrebbe apprendere. La regola deve essere applicata a reti che usano unità di output ad attivazione continua e differenziabile ed è l'elemento fondamentale dell'algoritmo di retropropagazione dell'errore ("backpropagation"), alla base dell'approccio connessionista.
Data una rete "in avanti" con le proprietà sopra descritte, l'obiettivo che ci si prefigge è minimizzare la diversità tra i valori di attivazione delle unità di output formula_62 della rete (ottenuti sommando i segnali provenienti dalle diverse unità di input formula_63 moltiplicati per l'efficacia, o "pesi sinaptici" formula_64 delle connessioni in ingresso), e i valori formula_65 della risposta desiderata. Tale diversità viene quantificata attraverso una funzione di perdita. La funzione obiettivo che si vuole minimizzare è il valore atteso della perdita (in pratica la perdita media sui dati).
Per applicare il metodo del gradiente, la funzione di perdita deve essere derivabile rispetto ai valori di output formula_62. Una scelta adatta a problemi di regressione è lo scarto quadratico medio tra formula_62 e formula_65 (valutato per tutte le unità di output e per tutti i pattern d'apprendimento); per problemi di classificazione si può utilizzare la divergenza di Kullback-Leibler o equivalentemente l'entropia incrociata.
Nella fase di addestramento, variando i pesi sinaptici formula_64 (parametri del modello) si può aumentare o diminuire la funzione obiettivo; la "prestazione" della rete sarà funzione delle variabili formula_64, e sarà massima quando si raggiunge il minimo della funzione obiettivo, il che si ottiene applicando il metodo del gradiente e aggiornando iterativamente i valori dei pesi sinaptici.
Poiché nelle applicazioni pratiche le dimensioni dei modelli e dei relativi dataset usati nell'addestramento sono molto grandi, in pratica si fa generalmente uso della discesa stocastica del gradiente per l'addestramento delle reti neurali e di altri modelli statistici e di apprendimento automatico.
</doc>

<doc id="2354612" url="https://it.wikipedia.org/wiki?curid=2354612" title="Clustering gerarchico">
Clustering gerarchico
In statistica e apprendimento automatico, il clustering gerarchico è un approccio di clustering che mira a costruire una gerarchia di cluster. Le strategie per il clustering gerarchico sono tipicamente di due tipi:
Il risultato di un clustering gerarchico è rappresentato in un dendrogramma.
Per decidere quali cluster devono essere combinati (approccio agglomerativo) o quale cluster deve essere suddiviso (approccio divisivo) è necessario definire una misura di dissimilarità tra cluster. Nella maggior parte dei metodi di clustering gerarchico si fa uso di metriche specifiche che quantificano la distanza tra coppie di elementi e di un criterio di collegamento che specifica la dissimilarità di due insiemi di elementi (cluster) come funzione della distanza a coppie tra elementi nei due insiemi.
La scelta di una metrica appropriata influenza la forma dei cluster, poiché alcuni elementi possono essere più "vicini" utilizzando una distanza e più "lontani" utilizzandone un'altra. Per esempio, in uno spazio a 2 dimensioni, la distanza tra il punto (1, 1) e l'origine (0, 0) è 2, formula_1 or 1 se si utilizzando rispettivamente le norme 1, 2 o infinito.
Metriche comuni sono le seguenti:
Il criterio di collegamento ("linkage criterion") specifica la distanza tra insiemi di elementi come funzione di distanze tra gli elementi negli insiemi.
Dati due insiemi di elementi "A" e "B" alcuni criteri comunemente utilizzati sono:
dove "d" è la metrica prescelta per determinare la similarità tra coppie di elementi.
</doc>

<doc id="263204" url="https://it.wikipedia.org/wiki?curid=263204" title="Macchine a vettori di supporto">
Macchine a vettori di supporto
Le macchine a vettori di supporto (SVM, dall'inglese "Support-Vector Machines") sono dei modelli di apprendimento supervisionato associati ad algoritmi di apprendimento per la regressione e la classificazione. Dato un insieme di esempi per l'addestramento (training set), ognuno dei quali etichettato con la classe di appartenenza fra le due possibili classi, un algoritmo di addestramento per le SVM costruisce un modello che assegna i nuovi esempi ad una delle due classi, ottenendo quindi un classificatore lineare binario non probabilistico. Un modello SVM è una rappresentazione degli esempi come punti nello spazio, mappati in modo tale che gli esempi appartenenti alle due diverse categorie siano chiaramente separati da uno spazio il più possibile ampio. I nuovi esempi sono quindi mappati nello stesso spazio e la predizione della categoria alla quale appartengono viene fatta sulla base del lato nel quale ricade.
Oltre alla classificazione lineare è possibile fare uso delle SVM per svolgere efficacemente la classificazione non-lineare utilizzando il metodo kernel, mappando implicitamente i loro input in uno spazio delle feature multi-dimensionale.
Quando gli esempi non sono etichettati è impossibile addestrare in modo supervisionato e si rende necessario l'apprendimento non supervisionato, questo approccio cerca di identificare i naturali cluster in cui si raggruppano i dati, mappando successivamente i nuovi dati nei cluster ottenuti. L'algoritmo di clustering a vettori di supporto, creato da Hava Siegelmann e Vladimir N. Vapnik, applica le statistiche dei vettori di supporto, sviluppate negli algoritmi delle SVM, per classificare dati non etichettati, ed è uno degli algoritmi di clustering maggiormente utilizzato nelle applicazioni industriali.
Le macchine a vettori di supporto possono essere pensate come una tecnica alternativa per l'apprendimento di classificatori polinomiali, contrapposta alle tecniche classiche di addestramento delle reti neurali artificiali.
Le reti neurali ad un solo strato hanno un algoritmo di apprendimento efficiente, ma sono utili soltanto nel caso di dati linearmente separabili. Viceversa, le reti neurali multistrato possono rappresentare funzioni non lineari, ma sono difficili da addestrare a causa dell'alto numero di dimensioni dello spazio dei pesi e poiché le tecniche più diffuse, come la "back-propagation", permettono di ottenere i pesi della rete risolvendo un problema di ottimizzazione non convesso e non vincolato che, di conseguenza, presenta un numero indeterminato di minimi locali.
La tecnica di addestramento SVM risolve entrambi i problemi: presenta un algoritmo efficiente ed è in grado di rappresentare funzioni non lineari complesse. I parametri caratteristici della rete sono ottenuti mediante la soluzione di un problema di programmazione quadratica convesso con vincoli di uguaglianza o di tipo box (in cui il valore del parametro deve essere mantenuto all'interno di un intervallo), che prevede un unico minimo globale.
Formalmente, una macchina a vettori di supporto costruisce un iperpiano o un insieme di iperpiani in uno spazio a più dimensioni o a infinite dimensioni, il quale può essere usato per classificazione, regressione e altri scopi come il rilevamento delle anomalie. Intuitivamente una buona separazione si può ottenere dall'iperpiano che ha la distanza maggiore dal punto (del training set) più vicino di ognuna delle classi; in generale maggiore è il margine fra questi punti, minore è l'errore di generalizzazione commesso dal classificatore.
Mentre il problema originale può essere definito in uno spazio di finite dimensioni, spesso succede che gli insiemi da distinguere non siano linearmente separabili in quello spazio. Per questo motivo è stato proposto che lo spazio originale di dimensioni finite venisse mappato in uno spazio con un numero di dimensioni maggiore, rendendo presumibilmente più facile trovare una separazione in questo nuovo spazio. Per mantenere il carico computazionale accettabile, i mapping utilizzati dalle SVM sono fatti in modo tale che i prodotti scalari dei vettori delle coppie di punti in input siano calcolati facilmente in termini delle variabili dello spazio originale, attraverso la loro definizione in termini di una funzione kernel formula_1scelta in base al problema da risolvere. Gli iperpiani in uno spazio multidimensionale sono definiti come l'insieme di punti il cui prodotto scalare con un vettore in quello spazio è costante, dove tale insieme di vettori è un insieme ortogonale (e quindi minimale) di vettori che definiscono un iperpiano. I vettori che definiscono gli iperpiani possono essere scelti come combinazioni lineari con parametri formula_2delle immagini dei vettori delle feature formula_3. Con tale scelta dell'iperpiano, i punti formula_4 nello spazio delle feature che sono mappati nell'iperpiano sono definiti dalla relazione formula_5. Si noti che se formula_1 diventa più piccolo al crescere di formula_7 rispetto ad formula_4, ogni termine della somma misura il grado di vicinanza del punto di test formula_4 al corrispondente punto di base formula_3. Si noti che l'insieme di punti formula_4 mappato in un qualsiasi iperpiano può produrre un risultato piuttosto complicato, permettendo discriminazioni molto più complesse fra insiemi non completamente convessi nello spazio originario.
L'originale algoritmo SVM è stato inventato da Vladimir Vapnik e Aleksej Červonenkis nel 1963.
Nel 1992 Bernhard Boser, Isabelle Guyon e lo stesso Vapnik suggerirono un modo per creare un classificatore non lineare applicando il metodo kernel all'iperpiano con il massimo margine. Lo standard corrente che propone l'utilizzo di un margine leggero fu invece proposto da Corinna Cortes e Vapnik nel 1993 e pubblicato nel 1995.
Alcune applicazioni per cui le SVM sono state utilizzate con successo
sono:
I seguenti framework mettono a disposizione un'implementazione di SVM:
</doc>

<doc id="255044" url="https://it.wikipedia.org/wiki?curid=255044" title="Intervallo di confidenza">
Intervallo di confidenza
In statistica, quando si stima un parametro, la semplice individuazione di un singolo valore è spesso non sufficiente.
È opportuno allora accompagnare la stima di un parametro con un intervallo di valori plausibili per quel parametro, che viene definito intervallo di confidenza (o intervallo di fiducia).
Se formula_1 e formula_2 sono variabili casuali con distribuzioni di probabilità che dipendono da qualche parametro formula_3 e formula_4 (dove formula_5 è un numero tra 0 e 1), allora l'intervallo casuale formula_6 è un intervallo di confidenza al formula_7 per formula_8. I valori estremi dell'intervallo di confidenza si chiamano "limiti di confidenza".
Ad esso si associa quindi un valore di probabilità cumulativa che caratterizza, indirettamente in termini di probabilità, la sua ampiezza rispetto ai valori massimi assumibili dalla variabile aleatoria misurando cioè la probabilità che l'evento casuale descritto dalla variabile aleatoria in oggetto cada all'interno di tale intervallo, graficamente pari all'area sottesa dalla curva di distribuzione di probabilità della variabile aleatoria nell'intervallo considerato.
È bene non confondere l'intervallo di confidenza con la probabilità. Data l'espressione "vi è un livello di confidenza del 95% che formula_9 sia nell'intervallo", nulla si può dire sulla probabilità che l'intervallo ottenuto contenga formula_10
Si ipotizzi di voler calcolare l'età media degli abitanti di un luogo. Supponiamo che non si conosca l'età per ogni singolo abitante. Viene allora estratto un campione casuale di abitanti di cui è possibile sapere l'età, e dal campione si tenta di inferire ("predire") l'età media per tutta la popolazione residente e la variabilità di tale dato. Questo può essere fatto calcolando, ad esempio, l'età media delle persone presenti nel campione e ipotizzando che questo valore coincida con l'età media di tutta la popolazione inclusa quella non scelta nel campione. In questo caso si è fatta una "stima puntuale". Alternativamente, a partire dalle età delle persone nel campione, si può calcolare un intervallo di valori entro il quale si ritenga ci sia il valore della media di tutta la popolazione e, se la procedura è fatta in modo rigoroso e statisticamente corretto, è possibile stabilire un valore di "confidenza" di quanto sia "credibile" che l'intervallo ottenuto contenga effettivamente il valore cercato. In questo caso si è fatta una "stima per intervalli" e l'intervallo ottenuto è detto "intervallo di confidenza".
Riassumendo: la stima puntuale fornisce un valore singolo che varia a seconda del campione, e difficilmente coincide con il valore vero della popolazione; la stima per intervalli fornisce un insieme di valori (intervallo) che con una certa "confidenza" contiene il valore vero della popolazione.
Se formula_11 è una variabile aleatoria di media formula_9 e varianza formula_13 con formula_14 si indica la variabile campionaria corrispondente che ha media aritmetica degli formula_15 dati osservati nel campione
e deviazione standard
Il livello di confidenza è fissato dal ricercatore. Il valore scelto più di frequente è 95%. Tuttavia, meno di frequente, viene scelto anche un livello di confidenza del 90%, oppure del 99%.
Se il valore di formula_18 non differisce molto dalla variabilità formula_19 della popolazione, può essere assunto come suo stimatore (ad esempio con un numero di soggetti osservati e replicazioni complessivamente maggiore di 60; in alternativa si ipotizza una distribuzione t di Student caratterizzata da una maggiore dispersione rispetto alla normale standard). In questa prima ipotesi, l'intervallo di confidenza per la media formula_9 ("vera media", della popolazione) al 99% (al livello formula_21), è dato da:
Al 95% è dato da:
Prima della diffusione dei computer si cercava di utilizzare l’approssimazione normale ogni qualvolta possibile. Adesso non è più strettamente necessario, e nella formula possono essere utilizzati percentili di altre distribuzioni, facendo rifierimento a campioni di dimensione più ridotta).
Dalle formule risulta che i due intervalli di confidenza possono essere scritti in funzione dei "soli dati campionari" formula_24.
Oltre a diminuire con il livello di confidenza, l'ampiezza dell'intervallo dipende dall'errore della stima formula_25 e diminuisce se:
Qualora la popolazione non segua il modello gaussiano, se il campione è grande a sufficienza, la variabile campionaria tende a seguire comunque una legge normale (teorema centrale del limite). In altre parole, le due formule precedenti per l'intervallo di confidenza si possono usare anche nel caso in cui non è nota la sua legge di probabilità.
Il livello di confidenza o copertura è il complemento a uno del livello di significatività formula_27: ad esempio, un intervallo di confidenza al formula_28 corrisponde a un livello di significatività di formula_29.
Gli intervalli di confidenza sono spesso confusi con altri concetti della statistica, e talora oggetto di errate interpretazioni anche da parte di ricercatori professionisti. Alcuni errori comuni:
Gli intervalli di confidenza furono introdotti da Jerzy Neyman in un articolo pubblicato nel 1937.
C'è un metodo agevole per il calcolo degli intervalli di confidenza attraverso il test di verifica d'ipotesi (secondo l'impostazione di Neyman).
Un intervallo di confidenza al 95% si può quindi ricavare da un test di verifica d'ipotesi di significatività 5%.
</doc>

<doc id="253357" url="https://it.wikipedia.org/wiki?curid=253357" title="Massimo e minimo di una funzione">
Massimo e minimo di una funzione
In matematica si dice che una funzione a valori reali:
ha in un punto formula_2 del proprio dominio formula_3 un massimo globale (o assoluto) se in formula_2 assume un valore maggiore o uguale a quello che assume negli altri punti di formula_3, ovvero
Viceversa formula_7 ha un minimo globale (o assoluto) in un punto formula_2 di formula_3 se
Si dice che una funzione formula_7 ha in formula_2 un massimo locale (o relativo) se formula_2 appartiene al dominio formula_3 di formula_7, è di accumulazione per formula_3, e inoltre formula_17 in un intorno di formula_2. 
formula_7 ha invece un minimo locale (o relativo) in formula_2 se formula_2 appartiene al dominio formula_3 di formula_7, è di accumulazione per formula_3, e inoltre formula_25 in un intorno di formula_2.
In tutti questi casi, si parla di formula_2 come di "punto di massimo" (o "di minimo") "assoluto" (o "relativo").
I punti di massimo e minimo vengono anche detti punti estremanti, e i valori assunti dalla funzione in questi punti sono detti estremi della funzione.
Nel caso di una funzione derivabile di una variabile reale la condizione necessaria, ma non sufficiente, affinché un punto possa, eventualmente, essere di massimo o di minimo locale è data dal teorema di Fermat, in base al quale la derivata prima di una funzione deve annullarsi se calcolata in corrispondenza di un punto di massimo o minimo locale:
Tale condizione permette di trovare un certo numero di punti ("x", "x", ...) che si chiamano punti critici o stazionari. Naturalmente questa condizione vale per tutti i punti interni al dominio di derivabilità, cioè nei punti interni di questo insieme, mentre negli estremi dell'insieme non è detto che la derivata esista e proprio per questo motivo la condizione vale per gli intervalli aperti. Questa condizione si può dimostrare: infatti se formula_2 è un punto di massimo locale, allora in un intorno formula_30 di "x" vale che il rapporto incrementale:
formula_31
per cui passando al limite di una funzione per formula_32 si deduce che necessariamente formula_33.
Geometricamente questa condizione significa che la retta tangente nel punto "x" è orizzontale. Tale condizione non è né necessaria né sufficiente per avere un massimo o un minimo locale: infatti da un lato ci possono essere punti di massimo o minimo locale anche laddove la funzione non è derivabile, e dall'altro ci possono essere punti (di flesso) dove la derivata si annulla ma la funzione non ha massimo o minimo locale.
Possiamo utilizzare la derivata prima per classificare i punti critici. Un punto formula_2 è di massimo locale per "f" se nei suoi intorni destro e sinistro:
Viceversa è di minimo locale se:
Se infine il valore della derivata non cambia attraversando il punto formula_2 allora questo è un punto di flesso ascendente o discendente a seconda che la derivata prima rimanga sempre positiva o sempre negativa.
Alternativamente se la funzione ammette la derivata seconda in un punto, un punto è di massimo o minimo relativo se la derivata prima della funzione si annulla (quindi formula_2 è un punto stazionario) e la derivata seconda non si annulla. Più precisamente, posto che la derivata prima si annulli, se la derivata seconda risulta essere maggiore di 0, allora significa che la concavità sarà rivolta verso l'alto, perciò il punto è di minimo. Mentre, se la derivata seconda è minore di zero, significa che la concavità è rivolta verso il basso e quindi si tratterà di un punto di massimo. Se invece la derivata seconda si annulla, nel caso in cui la derivata terza sia diversa da zero, avremo in quel punto un flesso a tangenza orizzontale ascendente o discendente e, per la definizione di flesso, la funzione cambierà concavità in tale punto.
Nel caso di funzioni in più variabili, il discorso fatto è analogo, ma ad annullarsi è il differenziale (e quindi il gradiente) della funzione. 
Nel caso di funzioni di 2 variabili, per verificare se il punto è di massimo o minimo, si guarda il segno del determinante della matrice hessiana e il primo termine della matrice: 
Nel caso di funzioni di 3 o più variabili, invece, si deve studiare il segno degli autovalori della matrice hessiana (nei punti critici, cioè dove si annulla il gradiente) e:
In caso di funzioni di due o più variabili, la ricerca dei punti di massimo e minimo non si esaurisce all'interno del dominio dove la funzione è derivabile, ma si devono cercare i massimi e i minimi anche sulla frontiera, in cui in generale la funzione non è differenziabile. In tal caso, nelle funzioni di due variabili si parametrizza la frontiera e si cercano i punti di massimo e di minimo come visto per una variabile reale.
Si consideri 
Calcoliamo la derivata prima:
Calcoliamo la derivata seconda: 
La derivata prima si annulla nei punti 
Nel punto formula_43 la derivata seconda è negativa, quindi è un punto di massimo, mentre nel punto formula_44 la derivata seconda è positiva, quindi è un punto di minimo.
Si consideri la funzione di 2 variabili
Calcoliamo le derivate parziali prime:
Quindi il gradiente di formula_48 è:
I punti critici sono dati dalla soluzione del sistema:
Quindi... 
formula_51 
oppure
formula_52 
Calcoliamo le derivate parziali seconde:
Quindi la matrice hessiana di z sarà:
Basandosi sul modello:
Calcoliamo la matrice hessiana nei punti critici (anche detti "punti stazionari"):
Questa matrice ha determinante negativo (-9), quindi è un punto di sella.
Questa seconda matrice ha invece determinante positivo (27) e primo termine (-6) negativo quindi è un punto di massimo relativo.
</doc>

<doc id="605" url="https://it.wikipedia.org/wiki?curid=605" title="Apprendimento automatico">
Apprendimento automatico
L’apprendimento automatico (noto anche come machine learning) è una branca dell'intelligenza artificiale che raccoglie un insieme di metodi, sviluppati a partire dagli ultimi decenni del XX secolo in varie comunità scientifiche, sotto diversi nomi quali: statistica computazionale, riconoscimento di pattern, reti neurali artificiali, filtraggio adattivo, teoria dei sistemi dinamici, elaborazione delle immagini, data mining, algoritmi adattivi, ecc; che utilizza metodi statistici per migliorare progressivamente la performance di un algoritmo nell'identificare pattern nei dati. Nell'ambito dell'informatica, l'apprendimento automatico è una variante alla programmazione tradizionale nella quale si predispone in una macchina l'abilità di apprendere qualcosa dai dati in maniera autonoma, senza ricevere istruzioni esplicite a riguardo.
Lo stesso Arthur Samuel che coniò il termine nel 1959 in linea di principio identifica due approcci distinti. Il primo metodo, indicato come rete neurale, porta allo sviluppo di macchine ad apprendimento automatico per impiego generale in cui il comportamento è appreso da una rete di commutazione connessa casualmente, a seguito di una routine di apprendimento basata su ricompensa e punizione (apprendimento per rinforzo). Il secondo metodo, più specifico, consiste nel riprodurre l'equivalente di una rete altamente organizzata progettata per imparare solo alcune attività specifiche. La seconda procedura, che necessita di supervisione, richiede la riprogrammazione per ogni nuova applicazione, ma risulta essere molto più efficiente dal punto di vista computazionale.
L'apprendimento automatico è strettamente legato al riconoscimento di pattern e alla teoria computazionale dell'apprendimento ed esplora lo studio e la costruzione di algoritmi che possano apprendere da un insieme di dati e fare delle predizioni su questi, costruendo in modo induttivo un modello basato su dei campioni. L'apprendimento automatico viene impiegato in quei campi dell'informatica nei quali progettare e programmare algoritmi espliciti è impraticabile; tra le possibili applicazioni citiamo il filtraggio delle email per evitare spam, l'individuazione di intrusioni in una rete o di intrusi che cercano di violare dati, il riconoscimento ottico dei caratteri, i motori di ricerca e la visione artificiale.
L'apprendimento automatico è strettamente collegato, e spesso si sovrappone con la statistica computazionale, che si occupa dell'elaborazione di predizioni tramite l'uso di computer. L'apprendimento automatico è anche fortemente legato all'ottimizzazione matematica, che fornisce metodi, teorie e domini di applicazione a questo campo. Per usi commerciali, l'apprendimento automatico è conosciuto come analisi predittiva.
L'apprendimento automatico si sviluppa con lo studio dell'intelligenza artificiale, e vi è strettamente collegato: infatti già dai primi tentativi di definire l'intelligenza artificiale come disciplina accademica, alcuni ricercatori si erano mostrati interessati alla possibilità che le macchine imparassero dai dati. Questi ricercatori, in particolare Marvin Minsky, Arthur Samuel e Frank Rosenblatt, provarono ad avvicinarsi al problema sia attraverso vari metodi formali, sia con quelle che vengono definite reti neurali nei tardi anni '50. Le reti neurali erano allora costituite da singoli percettroni e da modelli matematici derivati dal modello lineare generalizzato della statistica, come l'ADALINE di Widrow. Si provò a sfruttare anche ragionamenti probabilistici, in particolare nelle diagnosi mediche automatiche.
Sempre negli anni '50, Alan Turing propose l'idea di una "macchina che apprende", ovvero in grado di imparare e dunque diventare intelligente. La proposta specifica di Turing anticipa gli algoritmi genetici.
Tuttavia già dalla metà degli anni '50 lo studio dell'intelligenza artificiale si stava concentrando su approcci logici di tipo "knowledge-based", nota oggi sotto il nome di GOFAI, causando un distacco tra lo studio dell'IA e quello dell'apprendimento automatico. Sistemi di tipo probabilistico erano invasi di problemi sia teoretici sia pratici in termini di acquisizione e rappresentazione dei dati. Negli anni Ottanta, i sistemi esperti dominavano il campo dell'IA, e i sistemi basati sulla statistica non venivano più studiati.
Lo studio dell'apprendimento simbolico e "knowledge-based" continuò nell'ambito dell'IA, portando a sviluppare la programmazione logica induttiva, ma ora la ricerca più prettamente statistica si svolgeva al di fuori del campo vero e proprio dell'intelligenza artificiale, nel riconoscimento di pattern e nell'information retrieval.
Un altro motivo per cui lo studio dell'apprendimento automatico fu abbandonato fu la pubblicazione del libro "Perceptrons: an introduction to computational geometry" di Marvin Minsky e Seymour Papert, che vi descrivevano alcune delle limitazioni dei percettroni e delle reti neurali. La ricerca sulle reti neurali subì un significativo rallentamento a causa dell'interpretazione del libro, che le descriveva come intrinsecamente limitate. Anche la linea di ricerca sulle reti neurali continuò al di fuori del campo dell'IA, portata avanti da ricercatori provenienti da altre discipline quali Hopfield, Rumelhart, Hinton e Fukushima. Il loro successo principale fu a metà degli anni '80 con la riscoperta della "backpropagation" e della self-organization.
L'apprendimento automatico, sviluppatosi come campo di studi separato dall'IA classica, cominciò a rifiorire negli anni '90. Il suo obiettivo cambiò dall'ottenere l'intelligenza artificiale ad affrontare problemi risolvibili di natura pratica. Distolse inoltre la propria attenzione dagli approcci simbolici che aveva ereditato dall'IA, e si diresse verso metodi e modelli presi in prestito dalla statistica e dalla teoria della probabilità. L'apprendimento automatico ha inoltre beneficiato dalla nascita di Internet, che ha reso l'informazione digitale più facilmente reperibile e distribuibile.
Tom M. Mitchell ha fornito la definizione più citata di apprendimento automatico nel suo libro ""Machine Learning"": ""Si dice che un programma apprende dall'esperienza E con riferimento a alcune classi di compiti T e con misurazione della performance P, se le sue performance nel compito T, come misurato da P, migliorano con l'esperienza E."" In poche parole, si potrebbe semplificare dicendo che un programma apprende se c'è un miglioramento delle prestazioni dopo un compito svolto. Questa definizione di Mitchell è rilevante poiché fornisce una definizione operativa dell'apprendimento automatico, invece che in termini cognitivi. Fornendo questa definizione, Mitchell di fatto segue la proposta che Alan Turing fece nel suo articolo ""Computing Machinery and Intelligence"", sostituendo la domanda ""Le macchine possono pensare?"" con la domanda ""Le macchine possono fare quello che noi (in quanto entità pensanti) possiamo fare?"".
L'obiettivo principe dell'apprendimento automatico è che una macchina sia in grado di generalizzare dalla propria esperienza, ossia che sia in grado di svolgere ragionamenti induttivi. In questo contesto, per generalizzazione si intende l'abilità di una macchina di portare a termine in maniera accurata esempi o compiti nuovi, che non ha mai affrontato, dopo aver fatto esperienza su un insieme di dati di apprendimento. Gli esempi di addestramento (in inglese chiamati "training examples") si assume provengano da una qualche distribuzione di probabilità, generalmente sconosciuta e considerata rappresentativa dello spazio delle occorrenze del fenomeno da apprendere; la macchina ha il compito di costruire un modello probabilistico generale dello spazio delle occorrenze, in maniera tale da essere in grado di produrre previsioni sufficientemente accurate quando sottoposta a nuovi casi.
L'analisi computazionale degli algoritmi di apprendimento automatico e delle loro prestazioni è una branca dell'Informatica teorica chiamata teoria dell'apprendimento. Dato che gli esempi di addestramento sono insiemi finiti di dati e non c'è modo di sapere l'evoluzione futura di un modello, la teoria dell'apprendimento non offre alcuna garanzia sulle prestazioni degli algoritmi. D'altro canto, è piuttosto comune che tali prestazioni siano vincolate da limiti probabilistici. Il bias-variance tradeoff è uno dei modi di quantificare l'errore di generalizzazione.
Affinché la generalizzazione offra le migliori prestazioni possibili, la complessità dell'ipotesi induttiva deve essere pari alla complessità della funzione sottostante i dati. Se l'ipotesi è meno complessa della funzione, allora il modello manifesta "underfitting". Quando la complessità del modello viene aumentata in risposta, allora l'errore di apprendimento diminuisce. Al contrario invece se l'ipotesi è troppo complessa, allora il modello manifesta overfitting e la generalizzazione sarà più scarsa.
Oltre ai limiti di prestazioni, i teorici dell'apprendimento studiano la complessità temporale e la fattibilità dell'apprendimento stesso. Una computazione è considerata fattibile se può essere svolta in tempo polinomiale.
I compiti dell'apprendimento automatico vengono tipicamente classificati in tre ampie categorie, a seconda della natura del "segnale" utilizzato per l'apprendimento o del "feedback" disponibile al sistema di apprendimento. Queste categorie, anche dette paradigmi, sono:
A metà strada tra l'apprendimento supervisionato e quello non supervisionato c'è l'apprendimento semi-supervisionato, nel quale l'insegnante fornisce un dataset incompleto per l'allenamento, cioè un insieme di dati per l'allenamento tra i quali ci sono dati senza il rispettivo output desiderato. La trasduzione è un caso speciale di questo principio, nel quale l'intero insieme delle istanze del problema è noto durante l'apprendimento, eccetto la parte degli output desiderati che è mancante.
Un'altra categorizzazione dei compiti dell'apprendimento automatico si rileva quando si considera l'output desiderato del sistema di apprendimento automatico.
L'apprendimento automatico e la statistica sono discipline strettamente collegate. Secondo Michael I. Jordan, le idee dell'apprendimento automatico, dai principi metodologici agli strumenti teorici, sono stati sviluppati prima in statistica. Jordan ha anche suggerito il termine data science come nome con cui chiamare l'intero campo di studi.
Leo Breiman ha distinto due paradigmi statistici di modellazione: modello basato sui dati e modello basato sugli algoritmi, dove "modello basato sugli algoritmi" indica approssimativamente algoritmi di apprendimento automatico come la foresta casuale.
Alcuni statistici hanno adottato metodi provenienti dall'apprendimento automatico, il che ha portato alla creazione di una disciplina combinata chiamata "apprendimento statistico".
L'apprendimento automatico viene a volte unito al data mining, che si focalizza maggiormente sull'analisi esplorativa dei dati ed utilizza principalmente il paradigma di apprendimento chiamato "apprendimento non supervisionato". Invece, l'apprendimento automatico può essere anche supervisionato.
L'apprendimento automatico e il "data mining" infatti si sovrappongono in modo significativo, ma mentre l'apprendimento automatico si concentra sulla previsione basata su proprietà note apprese dai dati, il data mining si concentra sulla scoperta di proprietà prima "sconosciute" nei dati. Il data mining sfrutta i metodi dell'apprendimento automatico, ma con obiettivi differenti; d'altro canto, l'apprendimento automatico utilizza i metodi di data mining come metodi di apprendimento non supervisionato o come passi di preprocessing per aumentare l'accuratezza dell'apprendimento. Gran parte della confusione tra le due comunità di ricerca scaturisce dall'assunzione di base del loro operato: nell'apprendimento automatico, le prestazioni sono generalmente valutate in base all'abilità di riprodurre conoscenza già acquisita, mentre in data mining il compito chiave è la scoperta di conoscenza che prima non si aveva.
L'apprendimento automatico ha legami molto stretti con l'ottimizzazione: molti problemi di apprendimento sono formulati come la minimizzazione di una qualche funzione di costo su un insieme di esempi di apprendimento. La funzione di costo (o funzione di perdita) rappresenta la discrepanza tra le previsioni del modello che si sta addestrando e le istanze del problema reale. Le differenze tra i due campi (l'apprendimento automatico e l'ottimizzazione) sorgono dall'obiettivo della generalizzazione: mentre gli algoritmi di ottimizzazione possono minimizzare la perdita su un insieme di apprendimento, l'apprendimento automatico si preoccupa di minimizzare la perdita su campioni mai visti dalla macchina.
La risoluzione automatica di problemi avviene, nel campo dell'informatica, in due modi differenti: tramite paradigmi di "hard computing" o tramite paradigmi di "soft computing". Per "hard computing" si intende la risoluzione di un problema tramite l'esecuzione di un algoritmo ben definito e decidibile. La maggior parte dei paradigmi di "hard computing" sono metodi ormai consolidati, ma presentano alcuni lati negativi: infatti richiedono sempre un modello analitico preciso e definibile, e spesso un alto tempo di computazione. 
Le tecniche di "soft computing" d'altro canto antepongono il guadagno nella comprensione del comportamento di un sistema a scapito della precisione, spesso non necessaria. I paradigmi di "soft computing" si basano su due principi: 
L'apprendimento automatico si avvale delle tecniche di "soft computing".
La programmazione logica induttiva (anche ILP, dall'inglese "inductive logic programming") è un approccio all'apprendimento di regole che usa la programmazione logica come rappresentazione uniforme per gli esempi di input, per la conoscenza di base della macchina, e per le ipotesi. Data una codifica della (nota) conoscenza di base e un insieme di esempi rappresentati come fatti in una base di dati logica, un sistema ILP deriva un programma logico ipotetico da cui conseguono tutti gli esempi positivi, e nessuno di quelli negativi. La programmazione induttiva è un campo simile che considera ogni tipo di linguaggio di programmazione per rappresentare le ipotesi invece che soltanto la programmazione logica, come ad esempio programmi funzionali.
L'albero di decisione è un metodo di apprendimento per approssimazione di una funzione obiettivo discreta in cui l'elemento che apprende è rappresentato da un albero di decisione. Gli alberi di decisione possono essere rappresentati da un insieme di regole if-else per migliorare la leggibilità umana.
L'apprendimento automatico basato su regole di associazione è un metodo di apprendimento che identifica, apprende ed evolve delle "regole" con l'intento di immagazzinare, manipolare e applicare conoscenza. La caratteristica principale di questo tipo di apprendimento è l'identificazione ed utilizzo di un insieme di regole relazionali che rappresenta nel suo insieme la conoscenza catturata dal sistema. Ciò si pone in controtendenza con altri tipi di apprendimento automatico che normalmente identificano un singolo modello che può essere applicato universalmente ad ogni istanza per riuscire a fare su di essa una previsione. Gli approcci dell'apprendimento basato su regole di associazione includono il sistema immunitario artificiale.
Una rete neurale artificiale è un sistema adattivo che cambia la sua struttura basata su informazioni esterne o interne che scorrono attraverso la rete durante la fase di apprendimento.
In termini pratici le reti neurali sono strutture non-lineari di dati statistici organizzate come strumenti di modellazione. Esse possono essere utilizzate per simulare relazioni complesse tra ingressi e uscite che altre funzioni analitiche non riescono a rappresentare. Inoltre esse sono robuste agli errori presenti nel training data.
Gli algoritmi genetici forniscono un approccio all'apprendimento che è liberamente ispirato all'evoluzione simulata. La ricerca di una soluzione del problema inizia con una popolazione di soluzioni iniziale. I membri della popolazione attuale danno luogo a una popolazione di nuova generazione per mezzo di operazioni quali la mutazione casuale e crossover, che sono modellati sui processi di evoluzione biologica. Ad ogni passo, le soluzioni della popolazione attuale sono valutate rispetto a una determinata misura di fitness, con le ipotesi più adatte selezionate probabilisticamente come semi per la produzione della prossima generazione. Gli algoritmi genetici sono stati applicati con successo a una varietà di compiti di apprendimento e di altri problemi di ottimizzazione. Ad esempio, essi sono stati usati per imparare raccolte di norme per il controllo del robot e per ottimizzare la topologia dei parametri di apprendimento per reti neurali artificiali.
Il ragionamento bayesiano fornisce un approccio probabilistico di inferenza. Esso si basa sul presupposto che le quantità di interesse sono disciplinate da distribuzioni di probabilità e che le decisioni ottimali possono essere prese a seguito dell'analisi di queste probabilità insieme ai dati osservati. Nell'ambito dell'apprendimento automatico, la teoria Bayesiana è importante perché fornisce un approccio quantitativo per valutare le prove a sostegno dell'ipotesi alternativa. Il Ragionamento bayesiano fornisce la base per l'apprendimento negli algoritmi che manipolano direttamente le probabilità.
Macchine a vettori di supporto ("Support Vector Machine", SVM) sono un insieme di metodi di apprendimento supervisionato usati per la classificazione e la regressione di pattern. Dato un insieme di esempi di addestramento, ciascuno contrassegnato come appartenente a due possibili categorie, un algoritmo di addestramento SVM costruisce un modello in grado di prevedere a quale categoria deve appartenere un nuovo esempio di input.
La discesa dei prezzi per l'hardware e lo sviluppo di GPU per uso personale negli ultimi anni hanno contribuito allo sviluppo del concetto di apprendimento profondo, che consiste nello sviluppare livelli nascosti multipli nelle reti neurali artificiali. Questo approccio tenta di modellizzare il modo in cui il cervello umano processa luce e suoni e li interpreta in vista e udito. Alcune delle applicazioni più affermate dell'apprendimento profondo sono la visione artificiale e il riconoscimento vocale.
La cluster analisi, o clustering, è in grado di rilevare similarità strutturali tra le osservazioni di un dataset attraverso l'assegnazione di un insieme di osservazioni in sottogruppi ("cluster") di elementi tra loro omogenei. Il clustering è un metodo di apprendimento non supervisionato, e una tecnica comune per l'analisi statistica dei dati.
Tutti i sistemi di riconoscimento vocale di maggior successo utilizzano metodi di apprendimento automatico. Ad esempio, il SPHINXsystem impara le strategie di altoparlanti specifici per riconoscere i suoni primitivi (fonemi) e le parole del segnale vocale osservato. Metodi di apprendimento basati su reti neurali e su modelli di Markov nascosti sono efficaci per la personalizzazione automatica di vocabolari, caratteristiche del microfono, rumore di fondo, ecc.
Metodi di apprendimento automatico sono stati usati per addestrare i veicoli controllati da computer. Ad esempio, il sistema ALVINN ha usato le sue strategie per imparare a guidare senza assistenza a 70 miglia all'ora per 90 miglia su strade pubbliche, tra le altre auto. Con tecniche simili sono possibili applicazioni in molti problemi di controllo basato su sensori.
Metodi di apprendimento automatico sono stati applicati ad una varietà di database di grandi dimensioni per imparare regolarità generali implicito nei dati. Ad esempio, algoritmi di apprendimento basati su alberi di decisione sono stati usati dalla NASA per classificare oggetti celesti a partire dal secondo Palomar Observatory Sky Survey. Questo sistema è oggi utilizzato per classificare automaticamente tutti gli oggetti nel Sky Survey, che si compone di tre terabyte di dati immagine.
I programmi per computer di maggior successo per il gioco del backgammon sono basati su algoritmi di apprendimento. Ad esempio, il miglior programma di computer al mondo per backgammon, TD-Gammon, ha sviluppato la sua strategia giocando oltre un milione di partite di prova contro se stesso. Tecniche simili hanno applicazioni in molti problemi pratici in cui gli spazi di ricerca molto rilevanti devono essere esaminati in modo efficiente.
L'apprendimento automatico solleva un numero di problematiche etiche. I sistemi addestrati con insiemi di dati faziosi o pregiudizievoli possono esibire questi pregiudizi quando vengono interpellati: in questo modo possono essere digitalizzati pregiudizi culturali quali il razzismo istituzionale e il classismo. Di conseguenza la raccolta responsabile dei dati può diventare un aspetto critico dell'apprendimento automatico.
In ragione dell'innata ambiguità dei linguaggi naturali, le macchine addestrate su corpi linguistici necessariamente apprenderanno questa ambiguità.
</doc>

<doc id="3550" url="https://it.wikipedia.org/wiki?curid=3550" title="Probabilità condizionata">
Probabilità condizionata
In teoria della probabilità la probabilità condizionata di un evento "A" rispetto a un evento "B" è la probabilità che si verifichi "A", sapendo che "B" è verificato. Questa probabilità, indicata formula_1 o formula_2, esprime una "correzione" delle aspettative per "A", dettata dall'osservazione di "B".
Poiché, come si vedrà nella successiva definizione, formula_3 compare al denominatore, formula_1 ha senso solo se "B" ha una probabilità non nulla di verificarsi. 
È utile osservare che la notazione con il simbolo "Barra verticale" è comune con la definizione del connettivo logico NAND.
Per esempio, la probabilità di ottenere "4" con il lancio di un dado a sei facce (evento "A") ha probabilità "P(A)=1/6" di verificarsi. "Sapendo" però che il risultato del lancio è un numero tra "4", "5" e "6" (evento "B"), la probabilità di "A" diventa 
Si consideri questo secondo esempio, la probabilità di ottenere "1" con il lancio di un comune dado (evento "A") ha probabilità "P(A)=1/6" di verificarsi. "Sapendo" però che il risultato del lancio è un numero tra "4", "5" e "6" (evento "B"), la probabilità di "A" diventa 
La probabilità di "A" condizionata da "B" è
dove formula_8 è la probabilità congiunta dei due eventi, ovvero la probabilità che si verifichino entrambi.
In termini più rigorosi, dato uno spazio misurabile formula_9 di misura "P", ogni evento "B" eredita una struttura di spazio misurato formula_10, restringendo gli insiemi misurabili a quelli contenuti in "B", ed induce una nuova misura formula_11 su formula_9, con formula_13.
Se formula_14 è uno spazio probabilizzato (formula_15) e "B" non è trascurabile (formula_16), allora riscalando formula_17 a formula_18 si ottiene lo spazio probabilizzato formula_19 delle probabilità condizionate da "B".
La formula della probabilità condizionata permette di descrivere la probabilità congiunta come
Ovvero, la probabilità che si verifichino sia "A" sia "B" è pari alla probabilità che si verifichi "B" moltiplicata per la probabilità che si verifichi "A" supponendo che "B" sia verificato.
Due eventi "A" e "B" sono indipendenti quando vale una delle tre equazioni equivalenti
Per trovare la probabilità dell'evento a destra negato si può usare la seguente formula:
formula_24.
Se "A" e "B" sono eventi disgiunti, cioè se formula_25, le loro probabilità condizionate sono nulle: sapendo che uno dei due eventi si è verificato, è impossibile che si sia verificato "anche" l'altro.
Se l'evento "A" implica l'evento "B", cioè se formula_26, allora la loro intersezione è "A", per cui formula_27 e:
Nel caso di una misura di probabilità uniforme su uno spazio Ω finito, questa formula per "P(A|B)" esprime la definizione classica di probabilità come "casi favorevoli ("A") su casi possibili ("B")". 
Invece, per "P(B|A)" otteniamo il valore 1 che, per un numero finito di valori lo stesso Bayes interpretò in senso lato come la certezza che il tutto sia condizionato dalla parte.
La speranza condizionata formula_30 di una variabile aleatoria "X" ad un evento "B" è la speranza di "X" calcolata sulle probabilità formula_31 (condizionate da "B").
La probabilità di un evento "A" può essere condizionata da una variabile aleatoria discreta "X", originando una nuova variabile aleatoria, formula_32, che per "X=x" assume il valore formula_33.
Il teorema di Bayes esprime l'uguaglianza simmetrica formula_34 del teorema della probabilità composta come
Questo teorema è alla base dell'inferenza bayesiana in statistica, dove "P" è detta "probabilità "a priori" di "B"" e "P" "probabilità "a posteriori" di "B"".
Molti paradossi sono legati alla probabilità condizionata e derivano sia da un'errata formulazione del problema sia dalla confusione di "P(A|B)" con "P(A)" o con "P(B|A)".
Esempi particolari sono il paradosso delle due buste, il paradosso dei due bambini, il problema di Monty Hall e il paradosso di Simpson.
</doc>

<doc id="2735" url="https://it.wikipedia.org/wiki?curid=2735" title="Mediana (statistica)">
Mediana (statistica)
In statistica, in particolare in statistica descrittiva, data una distribuzione di un carattere quantitativo oppure qualitativo ordinabile (ovvero le cui modalità possano essere ordinate in base a qualche criterio), si definisce la mediana (o valore mediano) come il valore/modalità (o l'insieme di valori/modalità) assunto dalle unità statistiche che si trovano nel mezzo della distribuzione.
La mediana è un indice di posizione e rientra nell'insieme delle statistiche d'ordine.
Il termine "mediano" venne introdotto da Antoine Augustin Cournot e adottato da Francis Galton.
Gustav Theodor Fechner sviluppò l'uso della mediana come sostituto della media in quanto riteneva che il calcolo della media fosse troppo laborioso rispetto al vantaggio in termini di precisioni che offriva.
Se si procede al riordinamento delle unità in base ai valori crescenti del carattere da esse detenuto, in sostanza la mediana bipartisce la distribuzione in due sotto-distribuzioni: la prima a sinistra della mediana (costituita dalla metà delle unità la cui modalità è minore o uguale alla mediana) e la seconda a destra della mediana (costituita dalla metà delle unità la cui modalità è maggiore o uguale alla mediana). Tecnicamente si afferma che la mediana è il valore/modalità per il quale la frequenza relativa cumulata vale (o supera) 0,5, cioè il secondo quartile, ossia il 50° percentile. Usualmente si indica la mediana con Me.
Per calcolare la mediana di formula_1 dati:
Se le modalità sono raggruppate in classi non si definisce un valore univoco, ma una classe mediana formula_7.
La determinazione di tale classe avviene considerando le frequenze cumulate; indicando con formula_8 la generica frequenza cumulata relativa dell'osservazione i-esima sarà:formula_9 e formula_10. Pur essendo corretto considerare un qualsiasi elemento dell'intervallo formula_7 un valore mediano si è soliti procedere, al fine di avere una misura unica del valore, a un'approssimazione della mediana con la seguente formula:
se si assume che la distribuzione dei dati all'interno della classe sia uniforme, che corrisponde ad un processo di interpolazione.
Una proprietà della mediana è di rendere minima la somma dei valori assoluti degli scarti delle formula_13 da un generico valore
Infatti, sia formula_15 la variabile aleatoria alla quale si riferiscono le osservazioni formula_13. Per la linearità del valore atteso e dell'operatore di derivazione si ha
dove formula_18 è la funzione segno di formula_19. Per la definizione di valore atteso
dove formula_21 indica la probabilità che formula_15 sia minore di formula_23 e formula_24 quella che formula_15 sia maggiore di formula_23. Per le proprietà di normalizzazione della probabilità, cioè formula_27, l'equazione diventa
Quindi
cioè formula_23 è la mediana.
In un sondaggio fatto all'interno di una facoltà composta da 250 studenti (la popolazione statistica), si intende rilevare il carattere "Gradimento dei professori", secondo le cinque modalità "molto deluso", "insoddisfatto", "parzialmente soddisfatto", "soddisfatto", "entusiasta". Risulta che 10 studenti si dicono entusiasti dell'operato dei professori, 51 si dicono soddisfatti, 63 parzialmente soddisfatti, 90 insoddisfatti, 36 molto delusi.
La distribuzione di frequenza viene rappresentata con una tabella come la seguente:
Nel caso ipotizzato, la mediana è rappresentata dalla modalità "insoddisfatto". Questo significa che "almeno" la metà degli studenti non è soddisfatto dei professori.
</doc>

<doc id="847" url="https://it.wikipedia.org/wiki?curid=847" title="Campionamento statistico">
Campionamento statistico
In statistica il campionamento statistico (che si appoggia alla teoria dei campioni o teoria del campionamento), sta alla base dell'inferenza statistica, la quale si divide in due grandi capitoli: la teoria della stima e la verifica d'ipotesi.
In particolare, una rilevazione si dice "campionaria" quando è utile per fare inferenza ossia per desumere dal campione stesso un'informazione relativa all'intera popolazione.
Le indagini censuarie riguardano l'intera popolazione e pur essendo più affidabili riguardo al parametro oggetto d'indagine soffrono di:
Quindi mentre l'indagine censuaria fornisce il valore vero dei parametri di interesse (proporzioni, percentuali, medie, totali...) quella campionaria restituisce una sua stima al quale è associato un certo grado di fiducia (ovvero un'incertezza) quantificabile quando la formazione del campione risponde a determinati criteri di tipo probabilistico.
Il campionamento si usa quando si vuole conoscere uno o più parametri di una popolazione, senza doverne analizzare ogni elemento: questo per motivi di costi intesi in termini monetari, di tempo, di qualità o di disagio o perché analizzare un elemento lo distrugge rendendo inutilizzabile l'informazione ottenuta.
Modalità di selezione del campione sono:
Nella pratica quotidiana dei sondaggi di opinione e delle ricerche di mercato vengono usati tutti e quattro gli approcci.
La scelta di un tipo di campionamento avviene in base alle proprietà degli stimatori di alcuni parametri oppure per tener conto di problemi di costo, mobilità o altro.
Concetti chiave sono:
Benché già nel Settecento si sia notato il vantaggio nell'esaminare un sottinsieme della popolazione per generalizzare i risultati alla popolazione complessiva, è solo dalla fine dell'Ottocento che la discussione sulla "scientificità" del campionamento viene posta in modo esplicito alla comunità statistica.
Già agli inizi del Novecento si vanno delineando le caratteristiche che un campione deve avere, ovvero che deve essere scelto in maniera casuale, e nell'arco di pochi anni compaiono i primi studi che mettono in evidenza che il campione non deve essere necessariamente un campione semplice ma può essere più complesso, per esempio stratificando.
Importanti autori che hanno fatto la storia della teoria dei campioni sono stati tra gli altri: 
Nel 1925, durante il congresso di Roma, l'Istituto Internazionale di Statistica accetta definitivamente come scientifico il metodo campionario, distinguendo il campionamento casuale dal campionamento ragionato.
Altri autori importanti nella ricerca teorica ed applicata sul campionamento furono George Gallup e William G. Cochran.
</doc>

<doc id="1555" url="https://it.wikipedia.org/wiki?curid=1555" title="Scarto quadratico medio">
Scarto quadratico medio
Lo scarto quadratico medio (o deviazione standard o scarto tipo) è un indice di dispersione statistico, vale a dire una stima della variabilità di una popolazione di dati o di una variabile casuale.
È uno dei modi per esprimere la dispersione dei dati intorno ad un indice di posizione, quale può essere, ad esempio, la media aritmetica o una sua stima. Ha pertanto la stessa unità di misura dei valori osservati (al contrario della varianza che ha come unità di misura il quadrato dell'unità di misura dei valori di riferimento). In statistica la precisione si può esprimere come lo scarto quadratico medio.
Il termine ""standard deviation"" è stato introdotto in statistica da Pearson nel 1894 assieme alla lettera greca formula_1 (sigma) che lo rappresenta. Il termine italiano "deviazione standard" ne è la traduzione più utilizzata nel linguaggio comune; il termine dell'Ente Nazionale Italiano di Unificazione è tuttavia "scarto tipo", definito come la radice quadrata positiva della varianza per lo meno fin dal 1984.
Se non indicato diversamente, lo scarto quadratico medio è la radice quadrata della varianza, la quale viene coerentemente rappresentata con il quadrato di sigma (formula_2).
In statistica lo scarto quadratico medio di un carattere rilevato su una popolazione di formula_3 unità statistiche si definisce esplicitamente come:
dove formula_5 è la media aritmetica di formula_6.
Formalmente lo scarto quadratico medio di una variabile può essere calcolata a partire dalla funzione generatrice dei momenti, in particolare è la radice quadrata della differenza tra il momento secondo ed il momento primo elevato al quadrato.
A partire dallo scarto quadratico medio si definisce anche il coefficiente di variazione o la "deviazione standard relativa" come il rapporto tra lo scarto tipo formula_7 e il valore assoluto della media aritmetica della variabile in esame:
Questo indice relativo (che viene spesso espresso in termini percentuali) consente di effettuare confronti tra dispersioni di dati di tipo diverso, indipendentemente dalle loro quantità assolute.
Nell'ambito della statistica inferenziale (dove è noto solo un campione della popolazione), soprattutto nell'ambito della teoria della stima, a volte si rimpiazza il denominatore formula_3 con formula_10 ottenendo:
Sostanzialmente, poiché non è nota la media dell'intera popolazione, ma solo una sua stima (la media del campione), bisogna utilizzare formula_10 per ottenere uno stimatore corretto formula_13 della varianza incognita formula_7 di formula_6 sull'intera popolazione a partire dai dati del campione. La sua radice quadrata diviene lo scarto quadratico medio "corretto".
Questa correzione al denominatore fa sì che la nuova definizione sia un po' più grande della precedente, correggendo così la tendenza della precedente a sottostimare le incertezze soprattutto nel caso in cui si lavori con pochi dati (formula_3 piccolo).
Osserviamo il caso limite di formula_17, cioè quando si ha un campione di un solo elemento: la prima definizione dà il risultato formula_18, che ovviamente non è molto ragionevole nell'ambito della statistica inferenziale, mentre quella "corretta" dà un risultato non definito del tipo formula_19, rispecchiando così la totale ignoranza inerente all'incertezza su una singola misura. In questo senso, si dice che la statistica non dice nulla sul singolo caso.
Osserviamo che la differenza tra le due definizioni per campioni molto estesi è spesso numericamente insignificante.
Il calcolo può essere semplificato come segue:
cioè, applicando il tutto alla formula originale:
Sia formula_6 una variabile aleatoria, lo scarto quadratico medio è definito come la radice quadrata della varianza di formula_6
Formalmente lo scarto quadratico medio di una variabile aleatoria può essere calcolato a partire dalla funzione generatrice dei momenti, in particolare è la radice quadrata della differenza tra il momento secondo ed il momento primo elevato al quadrato, cioè
dove formula_26 è il valore atteso di formula_6.
In ambito finanziario, lo scarto quadratico medio viene usato per indicare la variabilità di un'attività finanziaria e dei suoi payoff (rendimenti). Esso fornisce quindi, implicitamente, una misura della volatilità dell'attività, quindi del suo rischio.
In fisica, è un ottimo indice dell'errore casuale della misurazione di una grandezza fisica.
In ambito sportivo è utilizzato per valutare la prestazione di un giocatore di bowling in riferimento ad un certo numero di partite. Il valore trovato non incide sul punteggio ma sintetizza le capacità e i miglioramenti del giocatore.
In ingegneria, è uno dei parametri da considerare per valutare la capacità di un processo produttivo.
Nelle applicazioni informatiche, è a volte conveniente utilizzare la formula
che consente, con sole tre variabili formula_29, di calcolare lo scarto quadratico medio, oltre che la media, di un flusso di numeri di lunghezza formula_3 senza dover ricorrere ad una memorizzazione degli stessi.
</doc>

<doc id="19781" url="https://it.wikipedia.org/wiki?curid=19781" title="Clustering">
Clustering
In statistica, il clustering o analisi dei gruppi (dal termine inglese "cluster analysis" introdotto da Robert Tryon nel 1939) è un insieme di tecniche di analisi multivariata dei dati volte alla selezione e raggruppamento di elementi omogenei in un insieme di dati. Le tecniche di "clustering" si basano su misure relative alla somiglianza tra gli elementi. In molti approcci questa similarità, o meglio, dissimilarità, è concepita in termini di distanza in uno spazio multidimensionale. La bontà delle analisi ottenute dagli algoritmi di "clustering" dipende molto dalla scelta della metrica, e quindi da come è calcolata la distanza. Gli algoritmi di "clustering" raggruppano gli elementi sulla base della loro distanza reciproca, e quindi l'appartenenza o meno ad un insieme dipende da quanto l'elemento preso in esame è distante dall'insieme stesso.
Le tecniche di "clustering" si possono basare principalmente su due "filosofie":
Esistono varie classificazioni delle tecniche di clustering comunemente utilizzate. Una prima categorizzazione dipende dalla possibilità che un elemento possa o meno essere assegnato a più cluster:
Un'altra suddivisione delle tecniche di clustering tiene conto del tipo di algoritmo utilizzato per dividere lo spazio:
Queste due suddivisioni sono del tutto trasversali, e molti algoritmi nati come "esclusivi" sono stati in seguito adattati nel caso "non-esclusivo" e viceversa.
Gli algoritmi di clustering di questa famiglia creano una partizione delle osservazioni minimizzando una certa funzione di costo:
dove formula_2 è il numero dei cluster, formula_3 è il formula_4-esimo cluster e formula_5 è la funzione di costo associata al singolo cluster. L'algoritmo più famoso appartenente a questa famiglia è il k-means, proposto da MacQueen nel 1967. Un altro algoritmo abbastanza conosciuto appartenente a questa classe è il Partitioning Around Medioid (PAM).
Le tecniche di clustering gerarchico non producono un partizionamento "flat" dei punti, ma una rappresentazione gerarchica ad albero. 
Questi algoritmi sono a loro volta suddivisi in due classi:
Una rappresentazione grafica del processo di clustering è fornita dal dendrogramma.
In entrambi i tipi di clustering gerarchico sono necessarie funzioni per selezionare la coppia di cluster da fondere ("agglomerativo"), oppure il cluster da dividere ("divisivo").
Nel primo caso, sono necessarie funzioni che misurino la "similarità" (o, indistintamente, la "distanza") tra due cluster, in modo da fondere quelli più simili. Le funzioni utilizzate nel caso agglomerativo sono:
Nei 4 casi precedenti, formula_10 indica una qualsiasi funzione distanza su uno spazio metrico.
Invece nel clustering divisivo è necessario individuare il cluster da suddividere in due sottogruppi. Per questa ragione sono necessarie funzioni che misurino la compattezza del cluster, la densità o la sparsità dei punti assegnati ad un cluster. Le funzioni normalmente utilizzate nel caso divisivo sono:
Nel "Clustering density-based", il raggruppamento avviene analizzando l'intorno di ogni punto dello spazio. In particolare, viene considerata la densità di punti in un intorno di raggio fissato.
Un esempio è il metodo di clustering Dbscan.
Algoritmi di clustering molto usati sono:
Il QT ("Quality Threshold") Clustering (Heyer et al., 1999) è un metodo alternativo di partizionare i dati, inventato per il clustering dei geni. Richiede più potenza di calcolo rispetto al "K"-Means, ma non richiede di specificare il numero di cluster "a priori", e restituisce sempre lo stesso risultato quando si ripete diverse volte.
L'algoritmo è:
La distanza tra un punto ed un gruppo di punti è calcolata usando il concatenamento completo, cioè come la massima distanza dal punto di ciascun membro del gruppo (vedi il "Clustering gerarchico agglomerativo" sulla distanza tra i cluster nella sezione clustering gerarchico).
</doc>

<doc id="3854" url="https://it.wikipedia.org/wiki?curid=3854" title="Scarto interquartile">
Scarto interquartile
In statistica lo scarto interquartile (o differenza interquartile o ampiezza interquartile, in inglese "interquartile range" o "IQR") è la differenza tra il terzo e il primo quartile, ovvero l'ampiezza della fascia di valori che contiene la metà "centrale" dei valori osservati.
Lo scarto interquartile è un indice di dispersione, cioè una misura di quanto i valori si allontanino da un valore centrale. Viene utilizzato nel disegno del diagramma box-plot.
Lo scarto interquartile di una variabile aleatoria si ottiene tramite la funzione di ripartizione, come differenza formula_1
Per una variabile casuale normale formula_2 lo scarto interquartile è circa formula_3.
Per una variabile casuale di Cauchy formula_4 lo scarto interquartile è formula_5.
</doc>

<doc id="4145289" url="https://it.wikipedia.org/wiki?curid=4145289" title="Distribuzione di probabilità a priori">
Distribuzione di probabilità a priori
Nell'ambito dell'inferenza statistica bayesiana, una distribuzione di probabilità a priori, detta spesso anche distribuzione a priori, di una quantità incognita "p" (per esempio, supponiamo "p" essere la proporzione di votanti che voteranno per il politico Rossi in un'elezione futura) è la distribuzione di probabilità che esprimerebbe l'incertezza di "p" prima che i "dati" (per esempio, un sondaggio di opinione) siano presi in considerazione. Il proposito è di attribuire incertezza piuttosto che casualità a una quantità incerta. La quantità incognita può essere un parametro o una variabile latente.
Si applica il teorema di Bayes, moltiplicando la distribuzione a priori per la funzione di verosimiglianza e quindi normalizzando, per ottenere la distribuzione di probabilità a posteriori, la quale è la distribuzione condizionata della quantità incerta una volta ottenuti i dati.
Spesso una distribuzione a priori è l'accertamento soggettivo (elicitazione) di una persona esperta. Quando possibile, alcuni sceglieranno una "distribuzione a priori coniugata" per rendere più semplice il calcolo della distribuzione a posteriori.
I parametri di una distribuzione a priori sono chiamati "iperparametri", per distinguerli dai parametri del modello dei dati sottostanti. Per esempio, se si sta usando una distribuzione beta per modellare la distribuzione di un parametro "p" di una distribuzione di Bernoulli, allora:
Una "distribuzione a priori informativa" esprime una specifica, definita informazione circa una variabile.
Un esempio è la distribuzione a priori per la temperatura di domattina.
Un approccio ragionevole è costruire la distribuzione a priori come una distribuzione normale con valore atteso uguale alla temperatura mattutina di oggi, con una varianza uguale alla varianza giorno per giorno della temperatura atmosferica, oppure come una distribuzione della temperatura per quel tal giorno dell'anno.
Questo esempio ha una proprietà in comune con molte distribuzioni a priori, ovvero che la distribuzione a posteriori di un problema (temperatura odierna) diventa la distribuzione a priori per un altro problema (temperatura di domani); l'evidenza preesistente, che è già stata tenuta in conto, è parte della distribuzione a priori e come ulteriore evidenza viene accumulata. 
La distribuzione a priori è largamente determinata dall'evidenza piuttosto che da qualche assunzione originale, sempre che l'assunzione originale ammetta la possibilità (ossia sia compatibile) con quello che l'evidenza suggerisce. I termini "a priori" e "a posteriori" sono generalmente relativi a un dato o un'osservazione specifica.
Una "distribuzione a priori non informativa" esprime vaghezza o informazione a carattere generale circa una variabile.
Il termine "non informativa" può essere un po' fuorviante; spesso, tale tipo di distribuzione è chiamata "a priori non molto informativa", oppure "a priori oggettiva", cioè una distribuzione che non è soggettivamente esplicitata.
Le distribuzioni a priori non informative possono esprimere informazione "oggettiva" come ad esempio "la variabile è positiva" oppure "la variabile è minore di tal limite".
La più semplice e vecchia regola per determinare una distribuzione a priori non informativa è il principio d'indifferenza, il quale assegna a tutti gli eventi uguale probabilità.
In problemi di stima parametrica, l'uso di una distribuzione a priori non informativa dà risultati che sono non troppo differenti dall'analisi statistica convenzionale. Questo accade in quanto la funzione di verosimiglianza fornisce la parte maggiore dell'informazione rispetto a quella fornita dalla distribuzione a priori non informativa nel determinare una distribuzione a posteriori.
Vari tentativi sono stati fatti per trovare probabilità a priori, cioè distribuzioni di probabilità in un certo senso logicamente richieste dalla natura di uno stato di incertezza; queste sono soggette a controversia filosofica, con i sostenitori del metodo bayesiano approssimativamente divisi in due scuole: i "bayesiani oggettivistici", che credono che tali distribuzioni a priori esistano in molte situazioni, e i "bayesiani soggettivisti" che credono che in pratica le distribuzioni a priori rappresentino giudizi di opinione che non possono essere rigorosamente giustificati. Per la maggiore le più forti argomentazioni a favore della scuola oggettivistica furono date da Edwin T. Jaynes.
Come esempio di una distribuzione a priori, dovuta a, consideriamo una situazione in cui sappiamo che una pallina è nascosta sotto una di tre tazze rovesciate, A, B o C, ma nessun'altra informazione è disponibile circa la sua posizione. In questo caso una distribuzione a priori uniforme di formula_1 sembra intuitivamente verosimile la sola scelta ragionevole. Più formalmente, noi possiamo vedere che il problema rimane lo stesso se scambiamo le lettere identificative "A", "B" e "C" delle tazze. Sarebbe perciò strano scegliere una distribuzione a priori per la quale una permutazione delle lettere causerebbe un cambio nella nostra predizione circa la posizione dove la pallina sarà trovata; la distribuzione a priori uniforme è la sola che preserva questa invarianza. Se si accetta questo principio di invarianza allora si può vedere che la distribuzione a priori uniforme è la distribuzione logicamente corretta che rappresenta questo stato di conoscenza a priori. Si avrà notato che questa distribuzione a priori è "oggettiva" nel senso di essere la scelta corretta per rappresentare un particolare stato di conoscenza, ma non è oggettiva nel senso di essere una caratteristica del sistema osservato indipendente dall'osservatore: in realtà la pallina esiste sotto una specifica tazza e in questa situazione ha solo senso parlare di probabilità se c'è un osservatore con una conoscenza limitata del sistema ossia della posizione della pallina sotto le tazze.
Come esempio più controverso, Jaynes pubblicò un argomento basato sui gruppi di Lie suggerente che la distribuzione a priori rappresentante in maniera completa l'incertezza sarebbe la distribuzione a priori di Haldane "p"(1 − "p"). L'esempio fornito da Jaynes è quello di trovare un chimico in un laboratorio e di chiedergli di eseguire ripetutamente degli esperimenti di dissoluzione in acqua. La distribuzione a priori di Haldane da prevalentemente la maggiore probabilità agli eventi formula_2 and formula_3, indicando che il campione ogni volta si scioglierà oppure no, con uguale probabilità. Tuttavia se sono stati osservati campioni non disciogliersi in un esperimento e disciogliersi in un altro, allora questa distribuzione a priori è aggiornata alla distribuzione uniforme sull'intervallo [0, 1]. Questo risultato si ottiene applicando il teorema di Bayes all'insieme di dati consistente in un'osservazione di dissoluzione e una di non dissoluzione, usando la distribuzione a priori precedente. sulla base che essa fornisce una distribuzione a posteriori impropria che pone il 100% del contenuto di probabilità sia a "p" = 0 o a "p" = 1 se un numero finito di esperimenti ha dato lo stesso risultato (ad esempio il discioglimento). La distribuzione a priori di Jeffreys "p"(1 − "p") è perciò preferita ("cfr." sotto).
Se lo spazio parametrico X è dotato di una struttura di gruppo naturale che lascia invariato il nostro stato di conoscenza bayesiano, allora la distribuzione a priori può essere costruita proporzionale alla Misura di Haar. Questo può essere visto come una generalizzazione del principio di invarianza che giustificava la distribuzione a priori uniforme dell'esempio delle tre tazze visto sopra. Per esempio, in fisica ci si aspetta che un esperimento dia i medesimi risultati indipendentemente dalla scelta dell'origine del sistema di coordinate. Questo induce la struttura gruppale del gruppo delle traslazioni su "X", il quale determina la distribuzione di probabilità a priori come una distribuzione a priori impropria costante. Analogamente alcuni sistemi fisici presentano un'invarianza di scala (ossia i risultati sperimentali sono indipendenti dal fatto che, ad esempio, usiamo centimetri o pollici). In tal caso il gruppo di scala è la struttura di gruppo naturale, e la corrispondente distribuzione a priori su "X" è proporzionale a 1/"x". Qualche volta risulta importante se viene usata la misura di Haar invariante a sinistra piuttosto che quella invariante a destra. Per esempio, le misure di Haar invarianti a destra e a sinistra sul gruppo affine non sono uguali. Berger (1985, p. 413) arguisce che la scelta corretta è la misura di Haar invariante a destra.
Un'altra idea, supportata da Edwin T. Jaynes, è di usare il principio di massima entropia (MAXENT). La motivazione è che l'entropia di Shannon di una distribuzione di probabilità misura l'ammontare di informazione contenuta nella distribuzione. Maggiore è l'entropia, minore è l'informazione fornita dalla distribuzione. Perciò, mediante la massimizzazione dell'entropia sopra un adeguato insieme di distribuzioni di probabilità su "X", si trova la distribuzione che è meno informativa nel senso che essa contiene il minore ammontare di informazione consistente con le costrizioni definite dall'insieme scelto. Per esempio, la distribuzione a priori di massima entropia su uno spazio discreto, dato solo il fatto che la probabilità è normalizzata a 1, è la distribuzione a priori che assegna uguale probabilità ad ogni stato. Mentre nel caso continuo, la distribuzione a priori di massima entropia con densità normalizzata, media nulla e varianza unitaria, è la ben nota distribuzione normale. Il principio di minima entropia incrociata generalizza il principio di massima entropia al caso di "aggiornamento" di una distribuzione a priori arbitraria con adeguate costrizioni nel senso di massima entropia.
Un'idea collegata, la distribuzione a priori di riferimento, fu introdotta da José-Miguel Bernardo. Qui l'idea è di massimizzare il valore atteso della divergenza di Kullback–Leibler della distribuzione a posteriori rispetto alla distribuzione a priori. Questo massimizza l'informazione attesa riguardante "X" quando la densità a priori è "p"("x"); perciò, in un certo senso, "p"("x") è la distribuzione a priori "meno informativa" riguardo X. La distribuzione a priori di riferimento è definita nel limite asintotico, cioè si considera il limite delle distribuzioni a priori così ottenute come il numero di dati va all'infinito. Nei problemi multivariati spesso vengono scelte come distribuzioni a priori oggettive le distribuzioni a priori di riferimento, dato che altre scelte (ad esempio la regola di Jeffreys possono portare a distribuzioni a priori dal comportamento problematico.
Distribuzioni a priori oggettive possono anche essere derivate da altri principi, come le teorie dell'informazione o le teorie della codifica (vedi ad esempio lunghezza di descrizione minima) oppure della statistica frequentista.
Problemi filosofici legati alle distribuzioni a priori non informative sono associati alla scelta di una metrica appropriata o scala di misurazione. Supponiamo di volere una distribuzione a priori per la valocità di un corridore a noi sconosciuto. Potremmo specificare, diciamo, per la sua velocità una distribuzione a priori di tipo normale, ma in alternativa potremmo specificare una distribuzione a priori normale per il tempo impiegato a percorrere 100 metri, il quale è proporzionale al reciproco della prima distribuzione a priori. Queste due distribuzioni a priori sono effettivamente differenti, ma non è chiaro quale delle due preferire. Il metodo, spesso sopravvalutato, di trasformazione dei gruppi di Jaynes può rispondere a tale questione in varie situazioni.
In maniera simile, se ci è chiesto di stimare una proporzione incognita tra 0 e 1, noi possiamo affermare che tutte le proporzioni sono ugualmente probabili ed usare una distribuzione a priori uniforme. Alternativamente, potremmo dire che tutti gli ordini di grandezza per la proporzione sono ugualmente probabili, e scegliere la distribuzione a priori logaritmica, la quale è la distribuzione a priori uniforme sul logaritmo della proporzione. La distribuzione a priori di Jeffreys tenta di risolvere questo problema calcolando una distribuzione a priori che esprime la medesima credenza indipendentemente dalla metrica utilizzata. La distribuzione a priori di Jeffreys per una proporzione incognita "p" è "p"(1 − "p"), che differisce da quella raccomandata da Jaynes.
Distribuzioni a priori basate sulla nozione di probabilità algoritmica vengono impiegate nel campo dell'inferenza induttiva come base induttiva in configurazioni del tutto generali.
Problemi pratici associati con le distribuzioni a priori non informative includono il requisito che la distribuzione a posteriori sia propria. Le distribuzioni a priori non informative su variabili continue, non limitate sono improprie. Questo non è necessariamente un problema se la distribuzione a posteriori è propria. Un altro argomento importante è quello in cui se una distribuzione a priori non informativa viene usata in maniera regolare, cioè con svariati insiemi di dati, allora essa avrebbe buone proprietà frequentiste. Normalmente un bayesiano non dovrebbe porsi questo problema, ma potrebbe essere importante farlo in questa situazione. Per esempio, uno potrebbe volere che qualsiasi regola di decisione basata sulla distribuzione a posteriori sia ammissibile sotto la funzionedi perdita adottata. Sfortunatamente, l'ammissibilità è difficile da verificare, nonostante vari risultati siano noti ("cfr." ad esempio, Berger and Strawderman, 1996). Il problema è particolarmente acuto con i modelli di Bayes gerarchici; le distribuzioni a priori usuali (ad esempio la distribuzione a priori di Jeffreys) possono dare regole di decisione praticamente inammissibili se impiegate ai livelli gerarchici più elevati.
Se il teorema di Bayes viene scritto come
allora è chiaro che si otterrebbe il medesimo risultato se tutte le probabilità a priori "P"("A") e "P"("A") fossero moltiplicate per una data costante; lo stesso sarebbe vero per una variabile casuale continua. Se la sommatoria al denominatore converge, le probabilità a posteriori sommeranno (o integreranno) ancora a 1 anche se i valori della distribuzione a priori non lo fanno, e in tal modo può solo essere necessario richiedere alle distribuzioni a priori di essere specificate nella proporzione corretta. Spingendo oltre questa idea, in molti casi non è neanche richiesto che la somma o l'integrale dei valori della distribuzione a priori sia finita per ottenere risposte significative circa le probabilità a posteriori. Quando questo è il caso, la distribuzione a priori è chiamata distribuzione a priori impropria. Tuttavia, se la distribuzione a priori è impropria, allora non è necessario che la distribuzione a posteriori sia propria. Questo è chiaro nella situazione in cui l'evento "B" è indipendente da tutti gli altri eventi "A".
Vari statistici usano le distribuzioni a priori improprie come distribuzioni a priori non informative. Per esempio, se hanno bisogno di una distribuzione a priori per la media e la varianza di una variabile casuale, allora essi assumono "p"("m", "v") ~ 1/"v" (per "v" > 0) il che suggerirebbe che qualsiasi valore per la media è "ugualmente probabile" e che un valore per la varianza positiva diventa "meno probabile" in proporzione inversa al suo valore. Molti autori (Lindley, 1973; De Groot, 1937; Kass and Wasserman, 1996) mettono in guardia contro il pericolo di sovra-interpretare tali distribuzioni a priori poiché non sono densità di probabilità. La loro sola rilevanza che esse hanno si trova nella distribuzione a posteriori corrispondente, fintanto che questa è ben definita per tutte le osservazioni. (La distribuzione a priori di Haldane è un tipico controesempio.)
Esempi di distribuzioni a priori includono:
Il concetto di probabilità algoritmica fornisce una via per specificare la probabilità delle distribuzioni a priori basata sulla complessità relativa di modelli presi in considerazione e tra loro alternativi.
</doc>

<doc id="4302983" url="https://it.wikipedia.org/wiki?curid=4302983" title="Foresta casuale">
Foresta casuale
Una foresta casuale (in inglese: "random forest") è un classificatore d'insieme ottenuto dall'aggregazione tramite bagging di alberi di decisione
L'algoritmo per la creazione di una una foresta casuale fu sviluppato orignariamente da Leo Breiman e Adele Cutler.
Il nome viene dalle foreste di decisione casuali che furono proposte per primo da Tin Kam Ho dei Bell Labs nel 1995.
Il metodo combina l'idea dell'insaccamento di Breiman della selezione casuale delle caratteristiche, introdotta indipendentemente da Ho e Amit Geman per costruire una collezione di alberi di decisione con la variazione controllata.
La selezione di un sottoinsieme di caratteristiche è un esempio del metodo del sottoinsieme casuale che, nella formulazione di Ho, è un modo di implementare la discriminazione stocastica proposta da Eugene Kleinberg.
</doc>

<doc id="4100372" url="https://it.wikipedia.org/wiki?curid=4100372" title="Rete neurale artificiale">
Rete neurale artificiale
Nel campo dell'apprendimento automatico, una rete neurale artificiale (in inglese "artificial neural network", abbreviato in ANN o anche come NN) è un modello computazionale composto di "neuroni" artificiali, ispirato vagamente dalla semplificazione di una rete neurale biologica.
Questi modelli matematici sono troppo semplici per ottenere una comprensione delle reti neurali biologiche, ma sono utilizzati per tentare di risolvere problemi ingegneristici di intelligenza artificiale come quelli che si pongono in diversi ambiti tecnologici (in elettronica, informatica, simulazione, e altre discipline).
Una rete neurale artificiale può essere realizzata sia da programmi software che da hardware dedicato (DSP, "Digital Signal Processing"). Questa branca può essere utilizzata in congiunzione alla logica fuzzy.
L'ampia varietà di modelli non può prescindere dal costituente di base, il neurone artificiale proposto da W.S. McCulloch e Walter Pitts in un famoso lavoro del 1943: ""A logical calculus of the ideas immanent in nervous activity"", il quale schematizza un combinatore lineare a soglia, con dati binari multipli in entrata e un singolo dato binario in uscita: un numero opportuno di tali elementi, connessi in modo da formare una rete, è in grado di calcolare semplici funzioni booleane.
Le prime ipotesi di apprendimento furono introdotte da D. O. Hebb nel libro del 1949: ""The organization of behavior"", nel quale vengono proposti collegamenti con i modelli complessi del cervello.
Nel 1958, J. Von Neumann nella sua opera ""The computer and the brain"" esamina le soluzioni proposte dai precedenti autori sottolineando la scarsa precisione che queste strutture possedevano per potere svolgere operazioni complesse.
Nello stesso anno, Frank Rosenblatt nel libro "Psychological review" introduce il primo schema di rete neurale, detto "Perceptron" (percettrone), antesignano delle attuali reti neurali, per il riconoscimento e la classificazione di forme, allo scopo di fornire un'interpretazione dell'organizzazione generale dei sistemi biologici. Il modello probabilistico di Rosenblatt è quindi mirato all'analisi, in forma matematica, di funzioni quali l'immagazzinamento delle informazioni, e della loro influenza sul riconoscimento dei pattern; esso costituisce un progresso decisivo rispetto al modello binario di McCulloch e Pitts, perché i suoi pesi sinaptici sono variabili e quindi il percettrone è in grado di apprendere.
L'opera di Rosenblatt stimola una quantità di studi e ricerche che dura per un decennio, e suscita un vivo interesse e notevoli aspettative nella comunità scientifica, destinate tuttavia ad essere notevolmente ridimensionate allorché nel 1969 Marvin Minsky e Seymour A. Papert, nell'opera ""An introduction to computational geometry"", mostrano i limiti operativi delle semplici reti a due strati basate sul percettrone, e dimostrano l'impossibilità di risolvere per questa via molte classi di problemi, ossia tutti quelli non caratterizzati da separabilità lineare delle soluzioni: questo tipo di rete neurale non è abbastanza potente: non è infatti neanche in grado di calcolare la funzione "or esclusivo" (XOR). A causa di queste limitazioni, al periodo di euforia dovuto ai primi risultati della cibernetica (come veniva chiamata negli anni sessanta) segue un periodo di diffidenza durante il quale tutte le ricerche in questo campo non ricevono più alcun finanziamento dal governo degli Stati Uniti d'America; le ricerche sulle reti tendono, di fatto, a ristagnare per oltre un decennio, e l'entusiasmo iniziale risulta fortemente ridimensionato.
Il contesto matematico per addestrare le reti MLP ("Multi-Layers Perceptron", ossia percettrone multistrato) fu stabilito dal matematico americano Paul Werbos nella sua tesi di dottorato (Ph.D.) del 1974. Non fu dato molto peso al suo lavoro tanto fu forte la confutazione dimostrata da Minsky e Papert anni prima, e solo l'intervento di J. J. Hopfield, nel 1982, che in un suo lavoro studia dei modelli di riconoscimento di pattern molto generali, si oppose in modo diretto alla confutazione di Minsky riaprendo così degli spiragli per la ricerca in questo campo.
Uno dei metodi più noti ed efficaci per l'addestramento di tale classe di reti neurali è il cosiddetto algoritmo di retropropagazione dell'errore (error backpropagation), proposto nel 1986 da David E. Rumelhart, G. Hinton e R. J. Williams, il quale modifica sistematicamente i pesi delle connessioni tra i nodi, così che la risposta della rete si avvicini sempre di più a quella desiderata. Tale lavoro fu prodotto riprendendo il modello creato da Werbos. L'algoritmo di retropropagazione ("backpropagation" o BP) è una tecnica d'apprendimento tramite esempi, costituente una generalizzazione dell'algoritmo d'apprendimento per il percettrone sviluppato da Rosenblatt nei primi anni '60. Mediante questa tecnica era possibile, come detto, trattare unicamente applicazioni caratterizzabili come funzioni booleane linearmente separabili.
L'algoritmo di apprendimento si basa sul metodo della discesa del gradiente che permette di trovare un minimo locale di una funzione in uno spazio a N dimensioni. I pesi associati ai collegamenti tra gli strati di neuroni si inizializzano a valori piccoli (ovvero molto inferiori ai valori reali che poi assumeranno) e casuali e poi si applica la regola di apprendimento presentando alla rete dei pattern di esempio. Queste reti neurali sono poi capaci di generalizzare in modo appropriato, cioè di dare risposte plausibili per input che non hanno mai visto.
L'addestramento di une rete neurale di tipo BP avviene in due diversi stadi: "forward-pass" e "backward-pass". Nella prima fase i vettori in input sono applicati ai nodi in ingresso con una propagazione in avanti dei segnali attraverso ciascun livello della rete ("forward-pass"). Durante questa fase i valori dei pesi sinaptici sono tutti fissati. Nella seconda fase la risposta della rete viene confrontata con l'uscita desiderata ottenendo il segnale d'errore. L'errore calcolato è propagato nella direzione inversa rispetto a quella delle connessioni sinaptiche. I pesi sinaptici infine sono modificati in modo da minimizzare la differenza tra l'uscita attuale e l'uscita desiderata ("backward-pass").
Tale algoritmo consente di superare le limitazioni del percettrone e di risolvere il problema della separabilità non lineare (e quindi di calcolare la funzione XOR), segnando il definitivo rilancio delle reti neurali, come testimoniato anche dall'ampia varietà d'applicazioni commerciali: attualmente la BP rappresenta un algoritmo di largo uso in molti campi applicativi.
Una rete neurale artificiale (ANN ""Artificial Neural Network"" in inglese), normalmente chiamata solo "rete neurale" (NN ""Neural Network"" in inglese), è un modello matematico/informatico di calcolo basato sulle reti neurali biologiche. Tale modello è costituito da un gruppo di interconnessioni di informazioni costituite da neuroni artificiali e processi che utilizzano un approccio di connessionismo di calcolo. Nella maggior parte dei casi una rete neurale artificiale è un sistema adattivo che cambia la propria struttura in base a informazioni esterne o interne che scorrono attraverso la rete stessa durante la fase di apprendimento.
In termini pratici le reti neurali sono strutture non-lineari di dati statistici organizzate come strumenti di modellazione. Esse possono essere utilizzate per simulare relazioni complesse tra ingressi e uscite che altre funzioni analitiche non riescono a rappresentare.
Una rete neurale artificiale riceve segnali esterni su uno strato di nodi (unità di elaborazione) d'ingresso, ciascuno dei quali è collegato con numerosi nodi interni, organizzati in più livelli. Ogni nodo elabora i segnali ricevuti e trasmette il risultato a nodi successivi.
Il concetto di rete neurale si pone perché una funzione formula_1 è definita come una composizione di altre funzioni formula_2, che possono a loro volta essere ulteriormente definite come composizione di altre funzioni. Questo può essere comodamente rappresentato come una struttura di reti, con le frecce raffiguranti le dipendenze tra variabili. Una rappresentazione ampiamente utilizzata è la somma ponderata non lineare, dove formula_3, dove formula_4 è una funzione predefinita, come ad esempio la tangente iperbolica. Sarà conveniente per le seguenti far riferimento ad un insieme di funzioni come un vettore formula_5.
La Figura 1 esemplifica una decomposizione della funzione formula_6, con dipendenze tra le variabili indicate dalle frecce. Queste possono essere interpretate in due modi:
I due punti di vista sono in gran parte equivalenti. In entrambi i casi, per questa particolare architettura di rete, i componenti dei singoli strati sono indipendenti l'uno dall'altro (ad esempio, le componenti di formula_8 sono indipendenti l'una dall'altra, dato il loro ingresso formula_15). Questo, naturalmente, permette un certo grado di parallelismo nella costruzione del sistema.
Reti, come ad esempio quelle precedenti vengono comunemente chiamate ""feedforward"", perché il loro è un grafico aciclico diretto. Reti con cicli al loro interno sono comunemente chiamati reti ricorrenti. Tali reti sono comunemente raffigurate nel modo indicato nella parte superiore della Figura 2, dove la funzione formula_6 è mostrata come dipendente su se stessa. Tuttavia, vi è una dipendenza temporale implicita che non è possibile dimostrare. Questo significa in pratica che il valore di formula_6 ad un certo punto nel tempo formula_18 dipende dai valori di formula_6 al tempo zero o su uno o più altri punti temporali. Il modello del grafico nella parte inferiore della Figura 2 illustra il caso in cui il valore di formula_6 al tempo formula_18 dipende solo dal suo valore finale.
Tuttavia la funzionalità più interessante di queste funzioni, ciò che ha attirato l'interesse e lo studio per la maggior parte delle reti neurali, è la possibilità di apprendimento, che in pratica significa la seguente:
Ciò comporta la definizione di una funzione di costo formula_24 tale che, per la soluzione ottimale formula_25 formula_26 nessuna soluzione ha un costo inferiore al costo della soluzione ottimale.
La funzione di costo formula_27 è un concetto importante nell'apprendimento, poiché si tratta di una misura di quanto è lontana da noi la soluzione ottimale del problema che vogliamo risolvere. Quindi vi sono una serie di algoritmi di apprendimento che cercano nello spazio delle soluzioni al fine di trovare una funzione che abbia il minor costo possibile.
Per applicazioni in cui la soluzione dipende da alcuni dati, il costo deve essere necessariamente funzione delle osservazioni.
Mentre è possibile definire per alcune reti una funzione di costo ad hoc, spesso si può utilizzare una particolare funzione di costo poiché gode delle proprietà desiderate (ad esempio, la convessità), o perché proviene da una particolare formulazione del problema (vale a dire, in una formulazione probabilistica, la probabilità a posteriori del modello può essere utilizzata come l'inverso del costo). In ultima analisi, la funzione di costo dipenderà dal compito.
Vi sono tre grandi paradigmi di apprendimento, ciascuno corrispondente ad un particolare compito astratto di apprendimento. Si tratta dell'apprendimento supervisionato, apprendimento non supervisionato e l'apprendimento per rinforzo. Di solito un tipo di architettura di rete può essere impiegato in qualsiasi di tali compiti.
L'algoritmo di apprendimento hebbiano (1984) si basa sul semplice principio che se due neuroni si attivano contemporaneamente, la loro interconnessione deve essere rafforzata.
formula_28 dove formula_29,
dove formula_30 è l'formula_31 ingresso e formula_32 è il tasso di apprendimento formula_33.
La regola di Hebb è la seguente: l'efficacia di una particolare sinapsi cambia se e solo se c'è un'intensa attività simultanea dei due neuroni, con un'alta trasmissione di input nella sinapsi in questione.
Esempio di procedura:
In questo modo le connessioni possono solo irrobustirsi.
Le connessioni si considerano irrobustite quando le unità presinaptica e postsinaptica sono d'accordo, altrimenti si indeboliscono.
Si considerano funzioni bipolari (-1,1) invece che booleane (0,1).
Le reti neurali si basano principalmente sulla simulazione di neuroni artificiali opportunamente collegati. Il modello rappresentato in figura è quello proposto da McCulloch e Pitts.
I suddetti neuroni ricevono in ingresso degli stimoli e li elaborano. L'elaborazione può essere anche molto sofisticata ma in un caso semplice si può pensare che i singoli ingressi vengano moltiplicati per un opportuno valore detto peso, il risultato delle moltiplicazioni viene sommato e se la somma supera una certa soglia il neurone si attiva attivando la sua uscita. Il peso indica l'efficacia sinaptica della linea di ingresso e serve a quantificarne l'importanza, un ingresso molto importante avrà un peso elevato, mentre un ingresso poco utile all'elaborazione avrà un peso inferiore. Si può pensare che se due neuroni comunicano fra loro utilizzando maggiormente alcune connessioni allora tali connessioni avranno un peso maggiore, fino a che non si creeranno delle connessioni tra l'ingresso e l'uscita della rete che sfruttano "percorsi preferenziali". Tuttavia è sbagliato pensare che la rete finisca col produrre un unico percorso di connessione: tutte le combinazioni infatti avranno un certo peso, e quindi contribuiscono al collegamento ingresso/uscita.
Il modello in figura rappresenta una classica rete neurale pienamente connessa.
I singoli neuroni vengono collegati alla schiera di neuroni successivi, in modo da formare una rete di neuroni. Normalmente una rete è formata da tre strati. Nel primo abbiamo gli ingressi (I), questo strato si preoccupa di trattare gli ingressi in modo da adeguarli alle richieste dei neuroni. Se i segnali in ingresso sono già trattati può anche non esserci. Il secondo strato è quello nascosto (H, "hidden"), si preoccupa dell'elaborazione vera e propria e può essere composto anche da più colonne di neuroni. Il terzo strato è quello di uscita (O) e si preoccupa di raccogliere i risultati ed adattarli alle richieste del blocco successivo della rete neurale. Queste reti possono essere anche molto complesse e coinvolgere migliaia di neuroni e decine di migliaia di connessioni.
Per costruire la struttura di una rete neurale multistrato si possono inserire formula_38 strati "hidden." L'efficacia di generalizzare di una rete neurale multistrato dipende ovviamente dall'addestramento che ha ricevuto e dal fatto di essere riuscita o meno ad entrare in un minimo locale buono.
L'algoritmo di retropropagazione dell'errore ("backpropagation") è utilizzato nell'apprendimento con supervisione. Esso permette di modificare i pesi delle connessioni in modo tale che si minimizzi una certa funzione errore E. Tale funzione dipende dal vettore h-esimo di output formula_39 restituito dalla rete, dato il vettore h-esimo di ingresso formula_40 e dal vettore h-esimo di output formula_41che noi desideriamo (che fa parte del training set). Il training set è dunque un insieme di N coppie di vettori formula_42, con formula_43. La funzione errore che si deve minimizzare si può scrivere come:
formula_44
dove l'indice k rappresenta il valore corrispondente al k-esimo neurone di output. E(w) è una funzione dipendente dai pesi (che in generale variano nel tempo), per minimizzarla si può usare l'algoritmo della discesa del gradiente ("gradient descent"). L'algoritmo parte da un punto generico formula_45 e calcola il gradiente formula_46. Il gradiente dà la direzione verso cui muoversi lungo la quale si ha il massimo incremento (o decremento se considero formula_47). Definita la direzione ci si muove di una distanza formula_32 predefinita a priori e si trova un nuovo punto formula_49 sul quale è calcolato nuovamente il gradiente. Si continua iterativamente finché il gradiente non è nullo.
L'algoritmo di backpropagation può essere diviso in due passi:
I passi logici per addestrare una rete neurale con apprendimento supervisionato sono i seguenti:
Per l'addestramento di reti neurali profonde, impiegando dataset molto vasti, la discesa del gradiente classica risulta computazionalmente proibitiva, per cui nell'ottimizzare i parametri del modello si fa tipicamente uso dell'algoritmo di discesa stocastica del gradiente.
Nel 1982, il fisico John J. Hopfield pubblica un articolo fondamentale in cui presenta un modello matematico comunemente noto appunto come rete di Hopfield: tale rete si distingue per "l'emergere spontaneo di nuove capacità computazionali dal comportamento collettivo di un gran numero di semplici elementi d'elaborazione". Le proprietà collettive del modello producono una memoria associativa per il riconoscimento di configurazioni corrotte e il recupero di informazioni mancanti.
Inoltre, Hopfield ritiene che ogni sistema fisico possa essere considerato come un potenziale dispositivo di memoria, qualora esso disponga di un certo numero di stati stabili, i quali fungano da attrattore per il sistema stesso. Sulla base di tale considerazione, egli si spinge a formulare la tesi secondo cui la stabilità e la collocazione di tali attrattori sono proprietà spontanee di sistemi costituiti, come accennato, da considerevoli quantità di neuroni reciprocamente interagenti.
Le applicazioni delle reti di Hopfield riguardano principalmente la realizzazione di memorie associative, resistenti all'alterazione delle condizioni operative, e la soluzione di problemi d'ottimizzazione combinatoriale.
Da un punto di vista strutturale, la rete di Hopfield costituisce una rete neurale ricorrente simmetrica, di cui è garantita la convergenza.
Una rete ricorrente è un modello neurale in cui è presente un flusso bidirezionale d'informazioni; in altri termini, mentre nelle reti di tipo feedforward la propagazione dei segnali avviene unicamente, in maniera continua, nella direzione che conduce dagli ingressi alle uscite, nelle reti ricorrenti tale propagazione può anche manifestarsi da uno strato neurale successivo ad uno precedente, oppure tra neuroni appartenenti ad uno stesso strato, e persino tra un neurone e sé stesso.
Un significativo e noto esempio di semplice rete ricorrente è dovuto a Jeffrey L. Elman (1990). Essa costituisce una variazione sul tema del percettrone multistrato, con esattamente tre strati e l'aggiunta di un insieme di neuroni "contestuali" nello strato d'ingresso. Le connessioni retroattive si propagano dallo strato intermedio (e nascosto) a tali unità contestuali, alle quali si assegna peso costante e pari all'unità.
In ciascun istante, gli ingressi si propagano nel modo tradizionale e tipico delle reti feedforward, compresa l'applicazione dell'algoritmo d'apprendimento (solitamente la "backpropagation"). Le connessioni retroattive fisse hanno come effetto quello di mantenere una copia dei precedenti valori dei neuroni intermedi, dal momento che tale flusso avviene sempre prima della fase d'apprendimento.
In questo modo la rete di Elman tiene conto del suo stato precedente, cosa che le consente di svolgere compiti di previsione di sequenze temporali che sono difficilmente alla portata dei percettroni multistrato convenzionali.
Infine, un ultimo interessante tipo di rete è costituita dalla cosiddetta mappa auto-organizzante o rete SOM ("Self-Organizing Map"). Tale innovativo tipo di rete neurale è stata elaborata da Teuvo Kohonen dell'Università Tecnologica di Helsinki; il suo algoritmo d'apprendimento è senza dubbio una brillante formulazione di apprendimento non supervisionato, e ha dato luogo a un gran numero di applicazioni nell'ambito dei problemi di classificazione. Una mappa o rete SOM è basata essenzialmente su un reticolo o griglia di neuroni artificiali i cui pesi sono continuamente adattati ai vettori presentati in ingresso nel relativo insieme di addestramento. Tali vettori possono essere di dimensione generica, anche se nella maggior parte delle applicazioni essa è piuttosto alta. Per ciò che riguarda le uscite della rete, al contrario, ci si limita di solito ad una dimensione massima pari a tre, il che consente di dare luogo a mappe 2D o 3D.
In termini più analitici, l'algoritmo può essere agevolmente descritto, come accennato, nei termini di un insieme di neuroni artificiali, ciascuno con una precisa collocazione sulla mappa rappresentativa degli "output", che prendono parte ad un processo noto come "winner takes all" ("Il vincitore piglia tutto"), al termine del quale il nodo avente un vettore di pesi più vicino ad un certo "input" è dichiarato vincitore, mentre i pesi stessi sono aggiornati in modo da avvicinarli al vettore in ingresso. Ciascun nodo ha un certo numero di nodi adiacenti. Quando un nodo vince una competizione, anche i pesi dei nodi adiacenti sono modificati, secondo la regola generale che più un nodo è lontano dal nodo vincitore, meno marcata deve essere la variazione dei suoi pesi. Il processo è quindi ripetuto per ogni vettore dell'insieme di "training", per un certo numero, solitamente grande, di cicli. Va da sé che ingressi diversi producono vincitori diversi.
Operando in tal modo, la mappa riesce alfine ad associare i nodi d'uscita con i gruppi o schemi ricorrenti nell'insieme dei dati in ingresso. Se questi schemi sono riconoscibili, essi possono essere associati ai corrispondenti nodi della rete addestrata. In maniera analoga a quella della maggioranza delle reti neurali artificiali, anche la mappa o rete SOM può operare in due distinte modalità:
In generale una ANN ("Attractor Neural Network") è una rete di nodi (es: biologicamente ispirati), spesso interconnessi in modo ricorsivo, la cui dinamica nel tempo stabilisce un assestamento in un particolare modo di oscillazione. Questo modo di oscillazione può essere stazionario, variante nel tempo o di tipo stocastico ed è chiamato il suo 'attrattore'. In neuroscienza teorica diversi tipi di reti ad attrattori sono state associate a differenti funzioni, come: memoria, attenzione, condotta del moto e classificazione.
Più precisamente, una rete ad attrattori è una rete di N nodi connessi in modo che la loro intera dinamica diventi stabile in uno spazio D dimensionale, dove solitamente N»D. Ciò assume che non vi sia più input dall'esterno del sistema. La stabilità nello stato ad attrattore indica l'esistenza di uno stato stabile in una qualche varietà algebrica (es: linea, cerchio, piano, toroide).
L'utilità dei modelli di rete neurale sta nel fatto che queste possono essere usate per comprendere una funzione utilizzando solo le osservazioni sui dati. Ciò è particolarmente utile nelle applicazioni in cui la complessità dei dati o la difficoltà di elaborazione rende la progettazione di una tale funzione impraticabile con i normali procedimenti di analisi manuale.
I compiti a cui le reti neurali sono applicate possono essere classificate nelle seguenti grandi categorie di applicazioni:
Le aree di applicazione includono i sistemi di controllo (controllo di veicoli, controllo di processi), simulatori di giochi e processi decisionali (backgammon, scacchi), riconoscimento di pattern (sistemi radar, identificazione di volti, riconoscimento di oggetti, ecc), riconoscimenti di sequenze (riconoscimento di gesti, riconoscimento vocale, OCR), diagnosi medica, applicazioni finanziarie, data mining, filtri spam per e-mail.
Le reti neurali per come sono costruite lavorano in parallelo e sono quindi in grado di trattare molti dati. Si tratta in sostanza di un sofisticato sistema di tipo statistico dotato di una buona immunità al rumore; se alcune unità del sistema dovessero funzionare male, la rete nel suo complesso avrebbe delle riduzioni di prestazioni ma difficilmente andrebbe incontro ad un blocco del sistema. I software di ultima generazione dedicati alle reti neurali richiedono comunque buone conoscenze statistiche; il grado di apparente utilizzabilità immediata non deve trarre in inganno, pur permettendo all'utente di effettuare subito previsioni o classificazioni, seppure con i limiti del caso.
Da un punto di vista industriale, risultano efficaci quando si dispone di dati storici che possono essere trattati con gli algoritmi neurali. Ciò è di interesse per la produzione perché permette di estrarre dati e modelli senza effettuare ulteriori prove e sperimentazioni.
I modelli prodotti dalle reti neurali, anche se molto efficienti, non sono spiegabili in linguaggio simbolico umano: i risultati vanno accettati "così come sono", da cui anche la definizione inglese delle reti neurali come "black box": in altre parole, a differenza di un sistema algoritmico, dove si può esaminare passo-passo il percorso che dall'input genera l'output, una rete neurale è in grado di generare un risultato valido, o comunque con una alta probabilità di essere accettabile, ma non è possibile spiegare come e perché tale risultato sia stato generato.
Come per qualsiasi algoritmo di modellazione, anche le reti neurali sono efficienti solo se le variabili predittive sono scelte con cura.
Non sono in grado di trattare in modo efficiente variabili di tipo categorico (per esempio, il nome della città) con molti valori diversi. Necessitano di una fase di addestramento del sistema che fissi i pesi dei singoli neuroni e questa fase può richiedere molto tempo, se il numero dei record e delle variabili analizzate è molto grande. Non esistono teoremi o modelli che permettano di definire la rete ottima, quindi la riuscita di una rete dipende molto dall'esperienza del creatore.
Le reti neurali vengono solitamente usate in contesti dove i dati possono essere parzialmente errati oppure dove non esistano modelli analitici in grado di affrontare il problema. Un loro tipico utilizzo è nei software di OCR, nei sistemi di riconoscimento facciale e più in generale nei sistemi che si occupano di trattare dati soggetti a errori o rumore. Esse sono anche uno degli strumenti maggiormente utilizzati nelle analisi di Data mining.
Le reti neurali vengono anche utilizzate come mezzo per previsioni nell'analisi finanziaria o meteorologica. Negli ultimi anni è aumentata notevolmente la loro importanza anche nel campo della bioinformatica nel quale vengono utilizzate per la ricerca di pattern funzionali e/o strutturali in proteine e acidi nucleici. Mostrando opportunamente una lunga serie di input (fase di training o apprendimento), la rete è in grado di fornire l'output più probabile. Negli ultimi anni inoltre sono in corso studi per il loro utilizzo nella previsione degli attacchi Epilettici (Analisi dei Dati provenienti dall' EEG).
Recenti studi hanno dimostrato buone potenzialità delle reti neurali in sismologia per la localizzazione di epicentri di terremoti e predizione della loro intensità.
</doc>

<doc id="5960762" url="https://it.wikipedia.org/wiki?curid=5960762" title="Retropropagazione dell'errore">
Retropropagazione dell'errore
La retropropagazione dell'errore (in lingua inglese "backward propagation of errors", solitamente abbreviato in backpropagation), è un algoritmo per l'allenamento delle reti neurali artificiali, usato in combinazione con un metodo di ottimizzazione come per esempio la discesa stocastica del gradiente.
La retropropagazione richiede un'uscita desiderata per ogni valore in ingresso per poter calcolare il gradiente della funzione di perdita (funzione di costo). Viene considerato quindi un metodo di apprendimento supervisionato, sebbene venga usato anche in reti non supervisionate come gli autocodificatori o Reti Diabolo.
È una generalizzazione della regola delta di reti feed-forward multistrato, resa possibile usando la regola di catena che iterativamente calcola i gradienti per ogni strato.
La retropropagazione richiede che la funzione d'attivazione usata dai neuroni artificiali (o "nodi") sia differenziabile.
Una delle principali difficoltà nell'uso della retropropagazione dell'errore è il problema noto come scomparsa del gradiente, dovuto all'uso di funzioni di attivazione non lineari che causano una diminuzione esponenziale del valore del gradiente all'aumentare della profondità della rete neurale.
</doc>

<doc id="5960768" url="https://it.wikipedia.org/wiki?curid=5960768" title="Rete neurale feed-forward">
Rete neurale feed-forward
Una rete neurale feed-forward ("rete neurale con flusso in avanti") o rete feed-forward è una rete neurale artificiale dove le connessioni tra le unità non formano cicli, differenziandosi dalle reti neurali ricorrenti. Questo tipo di rete neurale fu la prima e più semplice tra quelle messe a punto. In questa rete neurale le informazioni si muovono solo in una direzione, avanti, rispetto a nodi d'ingresso, attraverso nodi nascosti (se esistenti) fino ai nodi d'uscita. Nella rete non ci sono cicli. Le reti feed-forward non hanno memoria di input avvenuti a tempi precedenti, per cui l'output è determinato solamente dall'attuale input.
La più semplice rete feed-forward è il "percettrone a singolo strato" (SLP dall'inglese single layer perceptron), utilizzato verso la fine degli anni '60. Un SLP è costituito da un strato in ingresso, seguito direttamente dall'uscita. Ogni unità di ingresso è collegata ad ogni unità di uscita. In pratica questo tipo di rete neurale ha un solo strato che effettua l'elaborazione dei dati, e non presenta nodi nascosti, da cui il nome.
Gli SLP sono molto limitati a causa del piccolo numero di connessioni e dell'assenza di gerarchia nelle caratteristiche che la rete può estrarre dai dati (questo significa che è capace di combinare i dati in ingresso una sola volta). Famosa fu la dimostrazione che un SLP non riesce neanche a rappresentare la funzione XOR. Questo risultato, apparso nel 1969, scoraggiò i ricercatori e bloccò la ricerca sulle reti neurali per diversi anni.
Questa classe di reti feedforward si distingue dalla precedente dal fatto che tra lo strato di input e quello di output abbiamo uno o più strati di neuroni nascosti (hidden layers). Ogni strato ha connessioni entranti dal precedente strato e uscenti in quello successivo, quindi la propagazione del segnale avviene in avanti senza cicli e senza connessioni trasversali.
Questo tipo di architettura fornisce alla rete una prospettiva globale in quanto aumentano le interazioni tra neuroni.
</doc>

<doc id="6394873" url="https://it.wikipedia.org/wiki?curid=6394873" title="F1 score">
F1 score
Nell'analisi statistica della classificazione binaria, lF score (nota anche come F-score o F-measure, letteralmente "misura F") è una misura dell'accuratezza di un test. La misura tiene in considerazione precisione e recupero del test, dove la precisione è il numero di veri positivi diviso il numero di tutti i risultati positivi, mentre il recupero è il numero di veri positivi diviso il numero di tutti i test che sarebbero dovuti risultare positivi (ovvero veri positivi più falsi negativi). L'F viene calcolato tramite la media armonica di precisione e recupero:
Può assumere valori compresi fra 0 e 1. Assume valore 0 solo se almeno uno dei due vale 0, mentre assume valore 1 sia precisione che recupero valgono 1. L'F score è anche noto come coefficiente di Sørensen-Dice (DSC), o semplicemente coefficiente di Dice.
La formula generale è:
per valori di β reali positivi.
La formula in termini di errori di primo e secondo tipo:
Due particolari istanze della formula solitamente utilizzate sono la misura formula_4 (che pone maggiore enfasi sui falsi negativi) ed formula_5 (la quale attenua l'influenza dei falsi negativi).
In generale, formula_6 "misura l'efficacia del recupero rispetto ad un utente attribuisce al recupero un'importanza di β volte quella della precisione".
L'F-score è solitamente usata nel campo del recupero dell'informazione per misurare l'accuratezza delle ricerche o della classificazione dei documenti. Inizialmente l'F score era l'unica misura ad essere considerata, ma con la proliferazione in larga scala di motori di ricerca gli obiettivi di prestazione iniziarono a variare, divenendo necessario porre maggiore enfasi su precisione o recupero.
L'F-score è usata anche nel campo dell'apprendimento automatico ed è vastamente impiegata nella letteratura sull'elaborazione del linguaggio naturale.
Da notare, comunque, che non viene mai preso in considerazione il numero di veri negativi. In tal senso, misure come il coefficiente di correlazione di Matthews o il Kappa di Cohen possono generare risultati più adeguati alle proprie esigenze.
Mentre l'F-measure è una media armonica di recupero e precisione, la cosiddetta G-measure è una media geometrica:
Dove "PPV" sta per "Positive Predictive Value" ("valore predittivo positivo") e "TPR" per "True Positive Rate" (o indice di sensibilità).
È nota anche come indice di Fowlkes-Mallows.
</doc>

<doc id="1103542" url="https://it.wikipedia.org/wiki?curid=1103542" title="K-medoids">
K-medoids
K-medoids è un algoritmo di clustering partizionale correlato all'algoritmo K-means. Prevede in input un insieme di n oggetti e un numero k che determina quanti cluster si vogliono in output.
Entrambi gli algoritmi sono partizionali (suddividendo il dataset in gruppi) ed entrambi cercano di minimizzare l'errore quadratico medio, la distanza tra punti di un cluster e il punto designato per esserne il centro. In K-means il punto è "artificiale" — è la pura media di tutti i punti nel cluster. Nel K-medoids è usato il punto collocato più centralmente, in questo modo il centro è uno dei datapoint attuali. K-medoids è più robusto al rumore e agli outlier rispetto al k-means.
Un medoid può essere definito come un oggetto di un cluster la cui dissimilarità media rispetto a tutti gli oggetti nel cluster è minima, in questo modo esso sarà il punto più centrale di un dato dataset.
L'algoritmo di clustering è il seguente:
Si deve clusterizzare il seguente data set di 10 oggetti in 2 cluster, quindi n è 10 e k è 2:
Si inizializzano i k centri.
Assumiamo che C1=(3,4) e C2=(7,4) siano i nostri medoid iniziali.
Calcoliamo la distanza così da associare ogni data object al suo medoid più vicino.
Iniziamo quindi il clustering:
Essendo (3,4) (2,6) (3,8) e (4,7) punti vicini a c1 essi formeranno un cluster mentre i punti rimanenti ne formeranno un altro.
Il costo totale sarà 20.
Il costo tra 2 punti qualsiasi è trovato usando la formula
formula_1
Il costo totale è la somma dei costi per gli oggetti dal proprio medoid.
Costo totale= {cost((3,4),(2,6)) + cost((3,4),(3,8)) + cost((3,4),(4,7))} + {cost((7,4),(6,2)) + cost((7,4),(6,4)) + cost((7,4),(7,3)) + cost((7,4),(8,5)) + cost((7,4),(7,6))} = 3 + 4 + 4 + 3 + 1 + 1 + 2 + 2 = 20
Selezione di un nonmedoid O' in modo casuale.
Assumiamo O'=(7,3)
I medoid sono quindi c1(3,4) e O'(7,3).
Se c1 e O' sono nuovi medoid, si calcola il costo totale usando la formula al passo 1.
Costo totale = 3 + 4 + 4 + 2 + 2 + 1 + 3 + 3 = 22
Così il costo per cambiare il medoid da c2 a O' sarà:
S = Costo totale attuale – Costo totale precedente = 22 - 20 = 2 > 0
Quindi cambiare medoid in O' non è una buona idea, la scelta precedente è stata buona e l'algoritmo termina in questo punto (in quanto non ci sono cambiamenti per i medoid).
Può accadere che qualche data point possa migrare da un cluster ad un altro, ciò dipende dalla vicinanza rispetto al nuovo medoid scelto.
</doc>

<doc id="91024" url="https://it.wikipedia.org/wiki?curid=91024" title="Data mining">
Data mining
Il data mining (letteralmente dall'inglese "estrazione di dati") è l'insieme di tecniche e metodologie che hanno per oggetto l'estrazione di informazioni utili da grandi quantità di dati (es. database, datawarehouse ecc...), attraverso metodi automatici o semi-automatici (es. machine learning) e l'utilizzo scientifico, aziendale/industriale o operativo delle stesse.
La statistica può essere definita altrimenti come ""estrazione di informazione utile da insiemi di dati"".
Il concetto di "data mining" è simile, ma con una sostanziale differenza: la statistica permette di elaborare informazioni generali riguardo ad una popolazione (es. percentuali di disoccupazione, nascite), mentre il "data mining "viene utilizzato per cercare correlazioni tra più variabili relativamente ai singoli individui; ad esempio conoscendo il comportamento medio dei clienti di una compagnia telefonica cerco di prevedere quanto spenderà il cliente medio nell'immediato futuro.
In sostanza il data mining è ""l'analisi, da un punto di vista matematico, eseguita su database di grandi dimensioni"", preceduta tipicamente da altre fasi di preparazione/trasformazione/filtraggio dei dati come il data cleaning. Il termine "data mining" è diventato popolare nei tardi anni novanta come versione abbreviata della definizione appena esposta; oggi il "data mining" ha una duplice valenza:
In entrambi i casi i concetti di informazione e di significato sono legati strettamente al dominio applicativo in cui si esegue data mining, in altre parole un dato può essere interessante o trascurabile a seconda del tipo di applicazione in cui si vuole operare.
Questo tipo di attività è cruciale in molti ambiti della ricerca scientifica, ma anche in altri settori (per esempio in quello delle ricerche di mercato). Nel mondo professionale è utilizzata per risolvere problematiche diverse tra loro, che vanno dalla gestione delle relazioni con i clienti (CRM), all'individuazione di comportamenti fraudolenti, fino all'ottimizzazione di siti web.
I fattori principali che hanno contribuito allo sviluppo del data mining sono:
Le tecniche di data mining sono fondate su specifici algoritmi. I pattern identificati possono essere, a loro volta, il punto di partenza per ipotizzare e quindi verificare nuove relazioni di tipo causale fra fenomeni; in generale, possono servire in senso statistico per formulare previsioni su nuovi insiemi di dati.
Un concetto correlato al data mining è quello di apprendimento automatico ("Machine learning"); infatti, l'identificazione di pattern può paragonarsi all'apprendimento, da parte del sistema di data mining, di una relazione causale precedentemente ignota, cosa che trova applicazione in ambiti come quello degli algoritmi euristici e dell'intelligenza artificiale. Tuttavia, occorre notare che il processo di data mining è sempre sottoposto al rischio di rivelare relazioni causali che poi si rivelano inesistenti.
Tra le tecniche maggiormente utilizzate in questo ambito vi sono:
Un'altra tecnica molto diffusa per il data mining è l'apprendimento mediante classificazione. Questo schema di apprendimento parte da un insieme ben definito di esempi di classificazione per casi noti, dai quali ci si aspetta di dedurre un modo per classificare esempi non noti. Tale approccio viene anche detto "con supervisione" ("supervised"), nel senso che lo schema di apprendimento opera sotto la supervisione fornita implicitamente dagli esempi di classificazione per i casi noti; tali esempi, per questo motivo, vengono anche detti "training examples", ovvero "esempi per l'addestramento". La conoscenza acquisita per apprendimento mediante classificazione può essere rappresentata con un albero di decisione.
L'estrazione dei dati vera e propria giunge quindi al termine di un processo che comporta numerose fasi: si individuano le fonti di dati; si crea un unico set di dati aggregati; si effettua una pre-elaborazione (data cleaning, analisi esplorative, selezione, ecc.); si estraggono i dati con l'algoritmo scelto; si interpretano e valutano i pattern; l'ultimo passaggio va dai pattern alla nuova conoscenza così acquisita.
Vi sono diverse proposte e tecniche aventi ognuna specifiche caratteristiche e vantaggi.
Che cosa "è" "data mining"?
Che cosa "non è" "data mining"?
È una forma particolare di data mining nella quale i dati consistono in testi in lingua naturale, in altre parole, documenti "destrutturati". Il text mining unisce la tecnologia della lingua con gli algoritmi del data mining. L'obiettivo è sempre lo stesso: l'estrazione di informazione implicita contenuta in un insieme di documenti.
Ha avuto un notevole sviluppo, grazie ai progressi delle tecniche di elaborazione del linguaggio naturale (NLP in inglese), della disponibilità di applicazioni complesse attraverso gli "Application service provider" (ASP) e dell'interesse verso le tecniche automatiche di gestione della lingua mostrato sia dagli accademici, sia dai produttori di software, sia dai gestori dei motori di ricerca.
Una delle evoluzioni più recenti del data mining è la "data visualisation". Settore specialistico dell'infografica, la data visualisation si occupa non solamente di rendere graficamente intelligibile un testo, ma entra in relazione più diretta con la strutturazione dei database e l'esportazione di grafici dai dati.
Un'altra nuova frontiera è il «social data mining»: l'analisi di informazioni generate dalle reti sociali online, come ad esempio l'analisi del sentiment.
L'utilizzo del data mining nella ricerca di mercato è volto ad ampliare la conoscenza su cui basare i processi decisionali. Nel contesto aziendale il data mining è considerato parte del processo che porta alla creazione di un data warehouse. È efficace soprattutto per la valorizzazione delle informazioni aziendali residenti in questi grandi depositi di dati. Affinché l'informazione estratta dai dati esistenti sia significativa, e quindi potenzialmente utile, deve essere:
In questo contesto, un pattern (schema) non è altro che la rappresentazione delle relazioni chiave che vengono scoperte durante il processo di estrazione dati: sequenze ripetute, omogeneità, emergenza di regole, ecc. Per esempio, se un pattern mostra che i clienti di una certa area demografica sono molto propensi ad acquistare uno specifico prodotto, allora un'interrogazione ("query") selettiva ad un data warehouse di probabili compratori può essere usata per generare un elenco di indirizzi promozionali.
L'esempio classico spesso usato nei corsi universitari è quello di una catena non meglio specificata di supermercati (probabilmente statunitense) che avrebbe scoperto, analizzando gli scontrini, qualcosa altrimenti difficilmente immaginabile: le persone che acquistavano pannolini spesso compravano più birra degli altri, per cui mettendo la birra più costosa non lontano dai pannolini, poteva incrementarne le vendite. Infatti quelle persone che avevano figli piccoli passavano più serate in casa a guardare la TV bevendo birra in casa non potendo uscire con gli amici. È doveroso tuttavia precisare che non è chiaro quale sia la catena di supermercati in questione, e l'esempio, seppur ottimo per scopi didattici e largamente utilizzato anche in ambito giornalistico, potrebbe essere stato inventato così come potrebbe essere vero.
</doc>

<doc id="40388" url="https://it.wikipedia.org/wiki?curid=40388" title="Funzione di densità di probabilità">
Funzione di densità di probabilità
In matematica, una funzione di densità di probabilità (o PDF dall'inglese "probability density function") è l'analogo della funzione di probabilità di una variabile casuale nel caso in cui la variabile casuale formula_1 sia continua, cioè l'insieme dei possibili valori che ha la potenza del continuo.
Essa descrive la "densità" di probabilità in ogni punto nello spazio campionario.
La funzione di densità di probabilità di una variabile casuale formula_1 è un'applicazione formula_3 non negativa integrabile secondo Lebesgue e reale di variabile reale tale che la probabilità dell'insieme "A" sia data da
per tutti i sottinsiemi "A" dello spazio campionario.
Intuitivamente, se una distribuzione di probabilità ha densità formula_3, allora l'intervallo formula_6 ha probabilità formula_7. Da ciò deriva che la funzione formula_3 è un'applicazione definita come
Assumendo formula_10, ciò corrisponde al limite della probabilità che formula_11 si trovi nell'intervallo formula_6 per formula_13 che tende a zero. Di qui il nome di funzione di 'densità', in quanto essa rappresenta il rapporto tra una probabilità e un'ampiezza.
Per la condizione di normalizzazione l'integrale su tutto lo spazio di formula_3 deve essere 1. Di conseguenza ogni funzione non negativa, integrabile secondo Lebesgue, con integrale su tutto lo spazio uguale a 1, è la funzione densità di probabilità di una ben definita distribuzione di probabilità. Una variabile casuale che possiede densità si dice "variabile casuale continua".
Per le variabili casuali multivariate (o vettoriali) la trattazione formale è assolutamente identica: formula_15 si dice assolutamente continua se esiste una funzione a valori reali definita in formula_16, detta densità congiunta, tale che per ogni sottoinsieme "A" dello spazio campionario
Essa conserva tutte le proprietà di una densità scalare: è una funzione non negativa a integrale unitario su tutto lo spazio. Una proprietà importante è che se formula_15 è assolutamente continua allora lo è ogni sua componente; il viceversa invece non vale. La densità di una componente, detta densità marginale, si ottiene con un ragionamento analogo al teorema della probabilità assoluta, cioè fissando l'insieme di suoi valori di cui si vuole determinare la probabilità e lasciando libere di variare tutte le altre componenti. Infatti (nel caso bivariato per semplicità) l'evento formula_19 è l'evento formula_20, dunque
utilizzando il teorema di Fubini. La densità marginale di formula_1 è data dunque da
La funzione di densità della variabile casuale normale di media 0
e varianza 1 (detta "normale standard"), di cui a destra è riportato il grafico e l'espressione analitica della corrispondente densità nel caso generico (media formula_24 e varianza formula_25).
Un altro esempio può essere dato dalla densità di probabilità uniforme su un segmento (0,1). Si può verificare immediatamente che è densità di probabilità facendo l'integrale tra (0,1).
</doc>

<doc id="2246484" url="https://it.wikipedia.org/wiki?curid=2246484" title="Precisione e recupero">
Precisione e recupero
Precisione e recupero, o richiamo (in inglese "precision" e "recall") sono due comuni classificazioni statistiche, utilizzate in diversi ambiti del sapere, come per es. l'information retrieval. La precisione può essere vista come una misura di "esattezza" o fedeltà, mentre il recupero è una misura di "completezza".
Nell'Information Retrieval, la precisione è definita come il numero di documenti attinenti recuperati da una ricerca diviso il numero totale di documenti recuperati dalla stessa ricerca, e il recupero è definito come il numero di documenti attinenti recuperati da una ricerca diviso il numero totale di documenti attinenti esistenti (che dovrebbe essere stato recuperato).
In un processo di classificazione statistica, la precisione per una classe è il numero di veri positivi (il numero di oggetti etichettati correttamente come appartenenti alla classe) diviso il numero totale di elementi etichettati come appartenenti alla classe (la somma di veri positivi e falsi positivi, che sono oggetti etichettati erroneamente come appartenenti alla classe).
Recupero in questo contesto è definito come il numero di veri positivi diviso il numero totale di elementi che attualmente appartengono alla classe (per esempio la somma di veri positivi e falsi negativi, che sono oggetti che non sono stati etichettati come appartenenti alla classe ma dovrebbero esserlo).
Nell'Information Retrieval, un valore di precisione di 1.0 significa che ogni risultato recuperato da una ricerca è attinente mentre un valore di recupero pari a 1.0 significa che tutti i documenti attinenti sono stati recuperati dalla ricerca.
In un processo di classificazione, un valore di precisione di 1.0 per la classe C significa che ogni oggetto che è stato etichettato come appartenente alla classe C vi appartiene davvero (ma non dice niente sul numero di elementi della classe C che non sono stati etichettati correttamente) mentre un valore di recupero pari ad 1.0 significa che ogni oggetto della classe C è stato etichettato come appartenente ad essa (ma non dice niente sul numero di elementi etichettati non correttamente con C).
Nell'information retrieval, precisione e recupero sono definite in termini di insieme di documenti recuperati (lista di documenti restituiti da un motore di ricerca rispetto ad una query) e un insieme di documenti attinenti (lista di tutti i documenti che sono attinenti per l'argomento cercato).
formula_1
formula_2
In un processo di classificazione, i termini vero positivo, vero negativo, falso positivo e falso negativo sono usati per confrontare la classificazione di un oggetto (l'etichetta di classe assegnata all'oggetto da un classificatore) con la corretta classificazione desiderata (la classe a cui in realtà appartiene l'oggetto).
Precisione e recupero sono definite come:<br>
formula_3<br>
formula_4
La precisione è la probabilità che un documento recuperato (selezionato casualmente) sia attinente.
Il recupero è la probabilità che un documento attinente (selezionato casualmente) sia recuperato in una ricerca.
</doc>

<doc id="558366" url="https://it.wikipedia.org/wiki?curid=558366" title="Rete bayesiana">
Rete bayesiana
Una rete bayesiana (BN, "Bayesian network") è un modello grafico probabilistico che rappresenta un insieme di variabili stocastiche con le loro dipendenze condizionali attraverso l'uso di un grafo aciclico diretto (DAG). Per esempio una rete Bayesiana potrebbe rappresentare la relazione probabilistica esistente tra i sintomi e le malattie. Dati i sintomi, la rete può essere usata per calcolare la probabilità della presenza di diverse malattie.
Il termine "modello gerarchico" è talvolta considerato un particolare tipo di rete Bayesiana, ma non ha nessuna definizione formale. Qualche volta viene usato per modelli con tre o più livelli di variabili stocastiche; in altri casi viene usato per modelli con variabili latenti. Comunque in generale qualsiasi rete Bayesiana moderatamente complessa viene usualmente detta "gerarchica".
Formalmente le reti Bayesiane sono grafi diretti aciclici i cui nodi rappresentano variabili casuali in senso Bayesiano: possono essere quantità osservabili, variabili latenti, parametri sconosciuti o ipotesi. Gli archi rappresentano condizioni di dipendenza; i nodi che non sono connessi rappresentano variabili che sono condizionalmente indipendenti tra di loro. Ad ogni nodo è associata una funzione di probabilità che prende in input un particolare insieme di valori per le variabili del nodo genitore e restituisce la probabilità della variabile rappresentata dal nodo. Per esempio, se i genitori del nodo sono variabili booleane allora la funzione di probabilità può essere rappresentata da una tabella in cui ogni entry rappresenta una possibile combinazione di valori vero o falso che i suoi genitori possono assumere.
Esistono algoritmi efficienti che effettuano inferenza e apprendimento a partire dalle reti Bayesiane. Le reti Bayesiane che modellano sequenze di variabili che variano nel tempo sono chiamate reti Bayesiane dinamiche.
Matematicamente, una rete bayesiana è un grafo aciclico orientato in cui:
Una rete bayesiana rappresenta la distribuzione della probabilità congiunta di un insieme di variabili.
</doc>

<doc id="599528" url="https://it.wikipedia.org/wiki?curid=599528" title="K-means">
K-means
L'algoritmo K-means è un algoritmo di clustering partizionale che permette di suddividere un insieme di oggetti in K gruppi sulla base dei loro attributi. È una variante dell'algoritmo di aspettativa-massimizzazione (EM) il cui obiettivo è determinare i K gruppi di dati generati da distribuzioni gaussiane. Si assume che gli attributi degli oggetti possano essere rappresentati come vettori, e che quindi formino uno spazio vettoriale.
L'obiettivo che l'algoritmo si prepone è di minimizzare la varianza totale intra-cluster. Ogni cluster viene identificato mediante un centroide o punto medio. L'algoritmo segue una procedura iterativa. Inizialmente crea K partizioni e assegna ad ogni partizione i punti d'ingresso o casualmente o usando alcune informazioni euristiche. Quindi calcola il centroide di ogni gruppo. Costruisce quindi una nuova partizione associando ogni punto d'ingresso al cluster il cui centroide è più vicino ad esso. Quindi vengono ricalcolati i centroidi per i nuovi cluster e così via, finché l'algoritmo non converge.
Dati N oggetti con formula_1 attributi, modellizzati come vettori in uno spazio vettoriale formula_1-dimensionale, definiamo formula_3 come insieme degli oggetti. Ricordiamo che si definisce partizione degli oggetti il gruppo di insiemi formula_4 che soddisfano le seguenti proprietà:
Ovviamente deve valere anche che formula_8; non avrebbe infatti senso né cercare un solo cluster né avere un numero di cluster pari al numero di oggetti.
Una partizione viene rappresentata mediante una matrice formula_9, il cui generico elemento formula_10 indica l'appartenenza dell'oggetto formula_11 al cluster formula_1.
Indichiamo quindi con formula_13 l'insieme dei formula_14 centroidi.
A questo punto definiamo la funzione obiettivo come:
e di questa calcoliamo il minimo seguendo la procedura iterativa vista sopra:
Tipici criteri di convergenza sono i seguenti:
L'algoritmo ha acquistato notorietà dato che converge molto velocemente. Infatti, si è osservato che generalmente il numero di iterazioni è minore del numero di punti. Comunque, l'algoritmo può essere molto lento nel caso peggiore: D. Arthur e S. Vassilvitskii hanno mostrato che esistono certi insiemi di punti per i quali l'algoritmo impiega un tempo superpolinomiale, formula_24, a convergere. Più recentemente, A. Vattani ha migliorato questo risultato mostrando che l'algoritmo può impiegare tempo esponenziale, formula_25, a convergere anche per certi insiemi di punti sul piano. D'altra parte, D. Arthur, B. Manthey e H. Roeglin hanno mostrato che la smoothed complexity dell'algoritmo è polinomiale, la qual cosa è a supporto del fatto che l'algoritmo è veloce in pratica.
In termini di qualità delle soluzioni, l'algoritmo non garantisce il raggiungimento dell'ottimo globale. La qualità della soluzione finale dipende largamente dal set di cluster iniziale e può, in pratica, ottenere una soluzione ben peggiore dell'ottimo globale. Dato che l'algoritmo è di solito estremamente veloce, è possibile applicarlo più volte e fra le soluzioni prodotte scegliere quella più soddisfacente.
Un altro svantaggio dell'algoritmo è che esso richiede di scegliere il numero di cluster(k) da trovare. Se i dati non sono naturalmente partizionati si ottengono risultati strani. Inoltre l'algoritmo funziona bene solo quando sono individuabili cluster sferici nei dati.
È possibile applicare l'algoritmo K-means in Matlab utilizzando la funzione kmeans(DATA, N_CLUSTER), che individua N_CLUSTER numeri di cluster nel data set DATA. Il seguente m-file mostra una possibile applicazione dell'algoritmo per la clusterizzazione di immagini basata sui colori.
"img_segm.m"
La funzione legge l'immagine utilizzando la funzione Matlab imread, che riceve in ingresso il nome del file contenente l'immagine e restituisce una matrice il cui elemento formula_26 contiene il codice di colore del pixel i,j. Successivamente costruisce la matrice delle osservazioni con due semplici cicli for. Viene infine passata in ingresso all'algoritmo di clustering la matrice delle osservazioni e, dopo aver generato le matrici utili per visualizzare i cluster prodotti in un'immagine, queste vengono mostrate a video con la funzione image.
Ad esempio, eseguendo il comando:
img_segm('kmeans0.jpg',2);
si ottiene il seguente risultato:
</doc>

<doc id="3612028" url="https://it.wikipedia.org/wiki?curid=3612028" title="Classificazione statistica">
Classificazione statistica
La classificazione statistica è quell'attività che si serve di un algoritmo statistico al fine di individuare una rappresentazione di alcune caratteristiche di un'entità da classificare (oggetto o nozione), associandole una etichetta classificatoria. Tale attività può essere svolta mediante algoritmi di apprendimento automatico supervisionato o non supervisionato. Esempi di questi algoritmi sono:
I programmi che effettuano l'attività di classificazione sono detti classificatori. Talora si usa l'aggettivo "statistica" anche per classificazioni utilizzate per costruire indicazioni statistiche sulle entità assegnate ai diversi contenitori di una classificazione, soprattutto nel caso delle tassonomie, mentre nella definizione della classificazione non si sono utilizzati precisi metodi statistici.
</doc>

<doc id="3587354" url="https://it.wikipedia.org/wiki?curid=3587354" title="Distribuzione congiunta">
Distribuzione congiunta
In probabilità, date due variabili aleatorie "X" e "Y", definite sullo stesso spazio di probabilità, si definisce la loro distribuzione congiunta come la distribuzione di probabilità associata al vettore formula_1. Nel caso di due sole variabili, si parla di distribuzione bivariata, mentre nel caso di più variabili si parla di distribuzione multivariata.
La funzione di ripartizione di una distribuzione congiunta è definita come
o più generalmente
Nel caso di variabili aleatorie discrete, la densità discreta congiunta (o funzione di massa di probabilità congiunta) è data da
Siccome la densità congiunta è anch'essa una densità, è soddisfatta la seguente equazione:
Nel caso di variabili aleatorie continue, la densità congiunta è data da
dove "f"("y"|"x") e "f"("x"|"y") sono le distribuzioni condizionate di Y dato X=x e di X dato Y=y, mentre "f"("x") e "f"("y") sono le distribuzioni marginali della densità congiunta, rispettivamente per X e Y.
Anche in questo caso, è soddisfatto
</doc>
